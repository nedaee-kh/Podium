# پیام‌رسان

یکی از هیجان‌انگیزترین ویژگی‌های سرگرمی‌های آنلاینی مانند بازی‌های آنلاین، رقابت همزمان با سایر بازیکنان است. به‌ عنوان یک ارائه‌دهنده‌ی بازی آنلاین، با استفاده از سرویس پیام‌رسان پاد می‌توانید امکان برقراری ارتباط و ارسال انواع پیام میان اعضای یک تیم و همچنین اعضای تیم‌های رقیب در یک بازی را فراهم کنید و از این طریق هیجان شرکت در بازی‌ها را افزایش دهید.

<div class="box-end">
</div>

## نصب- جاوا اسکریپت

در صورتی که npm را نصب دارید، می‌توانید با خط دستور زیر سرویس پیام‌رسان را بر روی پروژه ی خود نصب نمایید.

```
npm install podchat --save

```




یا از طریق لینک زیر اقدام به دریافت فایل زیپ پروژه نمایید و آن را در محل پروژه‌ی خود extract کنید:

لینک گیت‌هاب:
https://github.com/FanapSoft/podchat

لینک npm:
https://www.npmjs.com/package/podchat

**پیش نیاز ها:**

هر کاربر جهت ورود نیازمند به یک توکن دسترسی است.

توکن دسترسی باید قبل از استفاده از سرویس پیام رسان ، از سرور sso دریافت شود تا به هنگام ساخت نمونه‌ی اولیه از شیء این سرویس به عنوان پارامتر به آن داده شود.

**ساخت نمونه اولیه:**

اولین قدم ساخت یک شیء نمونه از ماژول چت است.

```
var ChatSdk = require('podchat');

//params doc => https://docs.pod.land/document/chat-javascript-config
var Chat = new ChatSdk(params),

```




آدرس‌ها و تنظیمات لازم را به صورت لیستی از پارامترها به عنوان params به ورودی نمونه خود بدهید.

<div class="box-end">
</div>

## مدیریت مخاطبین

**۱- getContacts:**

دریافت لیست مخاطبین. این متد یک لیست جهت تنظیمات صفحه‌بندی (حداکثر تعداد مخاطبین در هر درخواست و شماره ی  شروع) دریافت می‌کند و لیست تمامی مخاطبین کاربر را بازمی‌گرداند.

به عنوان ورودی دوم نیز یک callback function دریافت می‌کند که پس از دریافت جواب اجرا خواهد شد.

```
var Params = {
   count: 50, //{**OPTIONAL**}
   offset: 0  //{**OPTIONAL**}
};

Chat.getContacts(Params, function(contactsResult) {
    console.log(contactsResult);
  });

```




**۲- addContacts:**

جهت اضافه کردن یک مخاطب جدید از این متد استفاده کنید. باید لیستی از مشخصات کاربر جدید را به عنوان ورودی در این تابع قرار دهید.نتیجه‌ی عملیات در callback قابل دریافت است.

نکته:
در صورت ارسال مقدار پارامتر firstName برای مخاطب، اجباری به ورود پارامتر نام خانوادگی(و بالعکس) نمی‌باشد و هم‌چنین در صورت ورود شماره موبایل، ورود ایمیل الزامی نیست (و بالعکس).

اما توجه داشته باشید ارسال مقادیر پارامتر(اگرچه بدون مقدار ورودی) الزامی می‌باشد.

```
 Chat.addContacts({
    firstName: "Sina",
    lastName: "Rahimi",
    cellphoneNumber: "0912*****85",
    email: "sinarahimi1@gmail.com"
  }, function(result) {
    console.log(result);
  });

```




**۳- updateContact:**

مشخصات جدید کاربر را به همرا id (همان آیدی مخاطب که پس از ذخیره ، یا به هنگام استفاده از سرویس لیست مخاطبین دریافت کرده اید) در لیست پارامتر ورودی به این متد بدهید تا عملیات تغییر مشخصات مخاطب مورد نظر صورت گیرد. پاسخ مشابه سرویس قبلی خواهد بود.

```
Chat.updateContacts({
    id: "661",
    firstName: "mohammad javad",
    lastName: "Rahimi",
    cellphoneNumber: "0938*****55",
    email: "newMail@gmail.com"
  }, function(result) {
    console.log(result);
  });

```




**۴- removeContact:** 

با دریافت آیدی مخاطب، مشخصات آن را حذف می‌کند.

```
Chat.removeContacts({
    id: "661" //{**REQUIRED**}
  }, function(result) {
    console.log(result);
  });

```




**۵-blockContact:**

با دریافت آیدی مخاطب،امکان ارتباط با او را مسدود می‌کند.

```
var data = {
    contactId: contactId //Required
  }

  Chat.block(data, function(result) {
    console.log(result);
  });

```




**۶- getBlockList:**

لیست مخاطبین بلاک شده را بازمی‌گرداند.

با پر کردن مقادیر ورودی count و offset می‌توانید تنظیمات صفحه بندی را اعمال کنید.

```
 var data = {
    count: 50,
    offset: 0
  }

  Chat.getBlocked(data, function(result) {
     console.log(result);
  });

```




**۷-unblock:**

با دریافت blockId (آیدی مخاطب از لیست مسدود شده‌ها)، امکان ارتباط مجدد با مخاطب را برقرار می‌کند و مخاطب از لیست مسدود شده ها خارج می‌شود.

```
var data = {
    blockId: blockId //Required
  }
  Chat.unblock(data, function(result) {
    console.log(result);
  });});

```




**۸- searchContact:**

با دریافت پارامترهای زیر، از بین مخاطبین کاربر به جستجو پرداخته و لیستی از مخاطبین با مشخصات داده شده را بازمی‌گرداند.

```
/*
*cellphoneNumber
*email
*firstName
*lastName
*uniqueId
*id
*offset 
*size 
*typeCode
*q
*/

  Chat.searchContacts({
    cellphoneNumber: 099
  }, function(result){
    if (!result.hasError) {
      console.log(result);
    }
  });

```



<div class="box-end">
</div>

## مدیریت پیام‌ها

**۱- sendTextMessage:**

ارسال پیام به یک ترد، با دریافت آیدی ترد و پیغام ارسالی. این متد لیستی شامل سه callback function دریافت می‌کند که برای مدیریت کاربر پس از ارسال پیغام(send) ، دریافت (deliver) و دیده شدن پیغام ارسالی توسط دیگر اعظای ترد(seen) است.

```
 sendChatParams = {
    threadId: threadId,  //{**REQUIRED**}
    content: message  //{**REQUIRED**}
  };

  Chat.send(sendChatParams, {
    onSent: function(result) {
       //your_code_for_sent_msg_in_app
      //console.log("\nYour message has been Sent!\n"); 
      console.log(result);
    },
    onDeliver: function(result) {
      //your_code_for_delivered_msg_in_app
      //console.log("\nYour message has been Delivered!\n"); 
      console.log(result);
    },
    onSeen: function(result) {
      //your_code_for_seen_msg_in_app
      //console.log("\nYour message has been Seen!\n"); 
      console.log(result);
    }
  });

```




**نکته:**

- سرویس پیام‌رسان (ارسال‌کننده‌ی پیغام)، تحویل پیغام به گیرنده را (از طریق متد deliver) به کاربر(فرستنده ی پیغام) اعلام می‌کند. ([Event Listeners](https://docs.pod.land/document/chat-javascript-eventlisteners))
- کاربر دریافت‌کننده‌ی پیغام باید رویت پیغام را از طریق متد seen به سرور (فرستنده ی پیغام) اعلام کند.

**۲- editMessage:**

با دریافت آیدی پیام و محتوای جدید ، پیغام مربوطه را ویرایش می‌کند.

نکته: سرور نتیجه ی تغییر پیغام را بر روی رویداد "messageEvents" با نوع "MESSAGE_EDIT" گزارش خواهد داد. (_Event Listeners_)

```
editChatParams = {
    messageId: messageId,  //{**REQUIRED**}
    content: newMessage  //{**REQUIRED**}
  };

  Chat.editMessage(editChatParams, function(result) {
    console.log(result);
  });

```




**۳- replyMessage:**

با دریافت آیدی ترد ، آیدی پیام ، و محتوای دلخواه ، پیام مورد نظر شما را انتخاب و محتوا را در پاسخ به آن پیام ارسال می‌کند.

با توجه به اینکه جنس این متد همانند sendTextMessage از نوع ارسال پیام است ، در نتیجه سه callback جهت عملیات پس از ارسال، دریافت، و دیده شدن پیام لازم خواهد داشت.

```
replyChatParams = {
    threadId: threadId, //{**REQUIRED**}
    repliedTo: messageId, //{**REQUIRED**}
    content: message //{**REQUIRED**}
  };

  Chat.replyMessage(replyChatParams, {
    onSent: function(result) {
      //console.log(result.uniqueId + " \t has been Sent! (Reply)");
       console.log(result);
    },
    onDeliver: function(result) {
      //console.log(result.uniqueId + " \t has been Delivered! (Reply)"); 
    },
    onSeen: function(result) {
      //console.log(result.uniqueId + " \t has been Seen! (Reply)"); 
    }
  });

```




**۴- forwardMessage:**

این متد ، باز ارسال یک پیام انتخابی را به یک ترد مشخص، با استفاده از آیدی پیام (جهت انتخاب آن) و آیدی ترد مقصد انجام خواهد داد. نوع این متد نیز ارسال پیام است.

```
Chat.forwardMessage({
    subjectId: destination, //threadId {**REQUIRED**}
    content: JSON.stringify(messageIds)  //{**REQUIRED**}
  }, {
    onSent: function(result) {
      //console.log(result.uniqueId + " \t has been Sent! (FORWARD)");
      console.log(result);
    },
    onDeliver: function(result) {
      console.log(result.uniqueId + " \t has been Delivered! (FORWARD)");
    },
    onSeen: function(result) {
      console.log(result.uniqueId + " \t has been Seen! (FORWARD)");
    }
  });

```




نکته: متد باز ارسال میتواند لیستی از پیام ها را با دریافت آیدی پیام ها به ترد مقصد ارسال کند. در این حالت برای هر پیام یک uniqueId جداگانه خواهد بود.

مثال:

```
destination = 312;
messageIds = [2539, 2538, 2537];
Chat.forwardMessage({
    subjectId: destination, //threadId
    content: JSON.stringify(messageIds)
  }, {
    onSent: function(result) {
      //console.log(result.uniqueId + " \t has been Sent! (FORWARD)");
      console.log(result);
    },
    onDeliver: function(result) {
      console.log(result.uniqueId + " \t has been Delivered! (FORWARD)");
    },
    onSeen: function(result) {
      console.log(result.uniqueId + " \t has been Seen! (FORWARD)");
    }
  });

```




**۵- sendFileMessage:**

ارسال پیام با محتوای فایل به یک ترد مشخص. با دریافت آیدی ترد مقصد، آدرس فایل مورد نظر، محتوای متن همراه عکس و محتوای مورد نظر متادیتا، فایل ارسالی را پس از آپلود بر روی سرور، به همراه پیام ارسالی به ترد مقصد ارسال می‌کند.

```
Chat.sendFileMessage({
    threadId: threadId, //{**REQUIRED**}
    file: file, //{**REQUIRED**}
    content: caption,
    metaData: metaData
  }, {
    onSent: function(result) {
      console.log(result.uniqueId + " \t has been Sent!");
    },
    onDeliver: function(result) {
      console.log(result.uniqueId + " \t has been Delivered!");
    },
    onSeen: function(result) {
      console.log(result.uniqueId + " \t has been Seen!");
    }
  });

```




نکته مهم: در صورتی که از فرم html استفاده میکنید به صورت مثال زیر آپلود نمایید.

```
/* html */

<form>
  <fieldset>
    <legend>Send File Message</legend>
    <input type="file" name="sendFileInput" id="sendFileInput">
    <br>
    <label for="sendFileDescription">Description: </label>
    <input type="text" name="sendFileDescription" id="sendFileDescription">
    <button type="button" name="button" id="sendFileMessage">Send</button>
  </fieldset>
</form>

```




```
/* js */

document.getElementById("sendFileMessage").addEventListener("click", function() {
  var fileInput = document.getElementById("sendFileInput"),
    image = fileInput.files[0],
    content = document.getElementById("sendFileDescription").value;

  Chat.sendFileMessage({
    threadId: 293,
    file: image,
    content: content,
    metaData: {custom_name: "John Doe"}
  }, {
    onSent: function(result) {
     // console.log(result.uniqueId + " \t has been Sent!");
    },
    onDeliver: function(result) {
     // console.log(result.uniqueId + " \t has been Delivered!");
    },
    onSeen: function(result) {
     // console.log(result.uniqueId + " \t has been Seen!");
    }
  });
});

```




**۶- deleteMessage:**

با دریافت آیدی پیام (messageId) ، پیام مربوطه را حذف خواهد کرد.

نکته: در صورتی که متغیر deleteForAll را با مقدار true پر کنید ، پیام مذکور از تاریخچه ی ترد همه‌‌ی اعضای آن ترد پاک خواهد شد.

```
Chat.deleteMessage({
    messageId: messageId, //{**REQUIRED**}
    deleteForAll: deleteForAll 
  }, function(result) {
    console.log(result);
  });

```




نکته: کلاینت‌های دیگر عضو این ترد، پس از پاک شدن یک پیغام از طریق رویدادهای ترد، با نوع THREAD_INFO_UPDATED مطلع می‌شوند.

**7- "deleteMultipleMessages":**

با دریافت آیدی ترد (threadId) و لیستی از آیدی پیام ها (messageIds) پیام‌های مربوطه را حذف خواهد کرد.

نکته: در صورتی که متغیر deleteForAll را با مقدار true پر کنید، پیام مذکور از تاریخچه‌ی ترد همه‌ی اعضای آن ترد پاک خواهد شد.

```
chatAgent.deleteMultipleMessages({
    threadId: 10298,
    messageIds: [47710, 47709, 47708],
    deleteForAll: true
}, function(result) {
    console.log("Delete Multiple Message Result", result);
});

```




بعد از ارسال دستور بالا، به ازای هر کدام از پیام‌های موجود در لیست آرایه ایه messageIds، یکبار Callback تعیین شده اجرا می‌شود. همچنین یک event مربوط به حذف پیام نیز توسط سرور ارسال می‌گردد.

```
// Callback

{
  hasError: false,
  cache: false,
  errorMessage: '',
  errorCode: 0,
  result: { deletedMessage: { id: 49228 } } 
}

// Message Delete Event

{ 
  type: 'MESSAGE_DELETE',
  result: { message: { id: 49228, threadId: 10424 } } 
}

```


<div class="box-end">
</div>

## مکانیزم Seen برای پیام ها

جهت این‌که برای پیام‌های ارسالی در یک ترد، به فرستنده،  پیام Seen ارسال شود. لازم است کلاینت از تابع chatAgent.seen() استفاده نماید.

چنانچه کلاینت آنلاین بوده و در داخل یک ترد در حال گفتگو باشد میتواند به محض مشاهده‌ی پیام برای پیام دیده شده Seen ارسال کند. اما اگرتعدادی پیام در یک ترد ارسال شده و کاربر بعد از مدتی وارد ترد شود، بایستی برای آخرین پیام دریافتی Seen ارسال کند. 

_**\* تبصره:**_ برای جلوگیری از ارسال Seen تکراری برای آخرین مسیج ترد، کلاینت می‌تواند از مقادیر lastSeenMessageId و lastSeenMessageTime و مقایسه این مقادیر با ID یا Time مسیجی که می‌خواهد برای آن Seen بفرستد، از ارسال Seen اضافی جلوگیری نماید.

**\** سناریوهای Seen شدن اتوماتیک برای پیام ها در سرور**

- زمانی که کاربر برای یک پیام، Seen ارسال می‌کند، سرور چت بصورت اتوماتیک، مقدار seen تمامی پیام‌های قبل از این پیام را True ست می‌کند. لذا کلاینت نیز باید بعد از ارسال Seen برای یک مسیج، تغییرات مد نظر خود برای نمایش Seen خوردن مسیج را برای تمامی مسیج های قبلی نیز اعمال نماید.
- چنانچه کاربر در یک ترد مسیجی ارسال کند، مقدار Seen برای تمامی مسیج‌های دریافتی اش در سرور به True تغییر می‌کند. لذا همانند حالت قبل، کلاینت باید UI خود را با این فرض بروزرسانی کند.

<div class="box-end">
</div>

## مدیریت Cache

ساختار کش برای SDK بصورت کاملا داخلی پیاده‌سازی شده و نیازی به پیاده‌سازی دوباره‌ی کش برای چت نیست. مقادیر کش تماما با استفاده از کلیدهای دریافت شده برای کاربر از سمت سرور SSO رمزنگاری شده اند و امکان سو استفاده از مقادیر کش شده بر روی سیستم وجود ندارد. چنانچه کاربری سعی بر دسترسی به مقادیر کش شده با کلید نادرست نماید، تمامی مقادیر برای حفظ امنیت کاربر از روی کش پاک می‌شوند.  کش با استفاده از IndexedDb  پیاده‌سازی شده و ساختار جداول به صورت زیر می‌باشد:

```
users: '&id, name, cellphoneNumber, keyId',
contacts: '[owner+id], id, owner, uniqueId, userId, cellphoneNumber, email, firstName, lastName, expireTime',
threads: '[owner+id] ,id, owner, title, time, [owner+time]',
participants: '[owner+id], id, owner, threadId, notSeenDuration, admin, name, contactName, email, expireTime',
messages: '[owner+id], id, owner, threadId, time, [threadId+id], [threadId+owner+time]',
messageGaps: '[owner+id], [owner+waitsFor], id, waitsFor, owner, threadId, time, [threadId+owner+time]'

```




**نکته:**
 جهت بهره برداری از سیستم کش، بایستی مقدار پارامتر enableCache در پارامترهای اولیه‌ی ورودی SDK چت به صورت True ست نمائید.

1- **,clearCacheDatabasesOfUser** :

سیستم کش پادچت بصورت چندین کاربره طراحی شده و چنانچه چندین کاربر با یک سیستم از چت استفاده نمایند، اطلاعات هرکدام با استفاده از کلیدهای رمزنگاری خود آن کاربر بر روی دیتابیس های کش ذخیره می‌شود. 

چنانچه بخواهید اطلاعات کش‌شده‌ی مربوط به کاربر جاری را از کش پاک کنید، کافیست متد clearCacheDatabasesOfUser را فراخوانی نمائید.

```
chatAgent.clearCacheDatabasesOfUser();

```




2- **,deleteCacheDatabases** :

چنانچه بخواهید اطلاعات کش‌شده‌ی مربوط به تمامی کاربران را از کش پاک کنید، کافیست متد **deleteCacheDatabases** را فراخوانی نمائید. این متد تمامی جداول کش را حذف نموده و دوباره می‌سازد.

```
chatAgent.deleteCacheDatabases();

```


<div class="box-end">
</div>

## مدیریت فایل‌ها  

سرویس‌های مدیریت فایل شامل موارد زیر می‌شود:

**۱- uploadImage:** 

با دریافت آدرس فایل عکس ، آن را بر روی سرور فایل ذخیره می‌کند. در صورتی که میخواهید عکس را برش دهید ، مختصات شروع برش و طول و عرض برش را به عنوان ورودی به متد ارسال کنید.

برش عکس

```
  Chat.uploadImage({
    image: "/your/image/path",
    xC: xC,
    yC: yC,
    hC: hC,
    wC: wC
  }, function(result) {
      console.log(result);
  });

```




نکته مهم: در صورتی که از فرم html استفاده می‌کنید به صورت مثال زیر آپلود نمایید.

```
/* html */

<form>
  <fieldset>
    <legend>Upload Image</legend>
    <input type="file" name="image" id="imageInput" value="">
    <button type="button" name="button" id="uploadImage">Upload Image</button>
    <br>
    <img id="uploadedImage" />
    <div id="uploadedImageData"></div>
  </fieldset>
</form>

/* js */

document.getElementById("uploadImage").addEventListener("click", function() {
  var imageInput = document.getElementById("imageInput"),
    image = imageInput.files[0];

  Chat.uploadImage({
    image: image,
    fileName: "Test Name",
    xC: 0,
    yC: 0,
    hC: 800,
    wC: 800
  }, function(result) {
    if (!result.hasError) {
      //your_code
    }
  });
});

```




**۲- getImage:**

با دریافت آیدی تصویر ذخیره شده و کد مشخصه‌ی آن (hashCode) لینک دریافت آن را در اختیار قرار می‌دهد.

```
 Chat.getImage({
    imageId: imageId,
    hashCode: hashCode
  }, function(result) {
    if (!result.hasError) {
      console.log(result);
    }
  });

```




**۳- uploadFile:**

با دریافت آدرس فایل آن را در سرور فایل بارگذاری خواهد کرد.

```
Chat.uploadFile({
    file: file
  }, function(result) {
      console.log(result);
  });

```




نکته مهم: در صورتی که از فرم html استفاده می‌کنید به صورت مثال زیر آپلود نمایید.

```
/* html */

<form>
  <fieldset>
    <legend>Upload File</legend>
    <input type="file" name="file" id="fileInput" value="">
    <button type="button" name="button" id="uploadFile">Upload File</button>
    <br>
    <div id="uploadedFile"></div>
  </fieldset>
</form>

/* js */

document.getElementById("uploadFile").addEventListener("click", function() {
  var fileInput = document.getElementById("fileInput"),
    file = fileInput.files[0];

  Chat.uploadFile({
    file: file,
    fileName: "Test Name"
  }, function(result) {
    if (!result.hasError) {
      //your_code
    }
  });
});

```




**۴- getFile:**

با دریافت آیدی فایل ذخیره شده و کد مشخصه‌ی آن (hashCode) لینک آن را در اختیار قرار می‌دهد.این متد پارامتری به عنوان downloadable دارد که از نوع boolean است. در صورت مثبت بودن لینک فایل خروجی قابل دانلود خواهد بود.

```
  Chat.getFile({
    fileId: fileId,
    hashCode: hashCode,
    downloadable: downloadable
  }, function(result) {
    if (!result.hasError) {
      //your_code
    }
  });

```



<div class="box-end">
</div>

## مدیریت پروفایل

**۱- getUserInfo:**

این متد اطلاعات پروفایل کاربر را در اختیارش قرار می‌دهد. با توجه به توکن دسترسی عمل می‌کند، لذا نیازی به ورودی ندارد.

```
 Chat.getUserInfo(function(userInfo) {
    console.log(userInfo);
  });

```




**2 -" isTyping":**

این متد دارای دو بخش متفاوت می‌باشد. در کل هدف ارسال بسته‌هایی شامل اطلاعات فرد در حال تایپ به سرور می‌باشد که سرور بتواند طرفین مقابل را از وضعیت تایپ کردن یوزر مطلع سازد.

برای استفاده از این امکان، کافیست همزمان با شروع تایپ توسط کاربر متد startTyping فراخوانی شده و مقدار threadId بدان ارسال شود. به صورت زیر: 

```
chatAgent.startTyping({threadId: 1431});

```




با فراخوانی متد startTyping به صورت اتوماتیک هر 1 ثانیه یکبار پیامی حاوی اطلاعات لازم برای سرور ارسال می‌گردد. در صورتی که عملیات تایپ کردن توسط کاربر به اتمام رسید. می‌توانید با فراخوانی متد stopTyping طرفین مقابل و سرور را از این موضوع باخبر سازید. به صورت زیر:

```
chatAgent.stopTyping();

```


<div class="box-end">
</div>

## "Event Listeners" 

**متد on:**

رخداد تمامی رویداد ها با متد on قابل دریافت خواهد بود. رویدادهای قابل مشاهده شامل موارد زیر است:

**۱- messageEvents:**

تمامی رویدادهایی که پس از فعل و انفعال پیام‌ها قابل رخداد است با این نام قابل دریافت است. message events یا رویدادهای پیام دلایل مختلفی دارد ، که به فراخور آن می‌توانید عملیات مورد نظر خود را سمت اپلیکیشن انجام دهید.

```
/**
 \* Listen to Message Events
 \*/
Chat.on("messageEvents", function(event) {
  var type = event.type,
    message = event.result.message;

  console.log(event);

  switch (type) {
    case "MESSAGE_NEW":
      /**
       \* Sending Message Seen to Sender after 5 secs
       \*/
      setTimeout(function() {
        Chat.seen({messageId: message.id, ownerId: message.ownerId});
      }, 5000);

      break;

    case "MESSAGE_EDIT":
      //your_code
      break;

    case "MESSAGE_DELIVERY":
      break;

    case "MESSAGE_SEEN":
      break;

    default:
      break;
  }
});

```




,message events شامل eventهای زیر است:

, MESSAGE_NEW: با دریافت پیام جدید این رویداد رخ خواهد داد.
 ,MESSAGE_EDIT: ویرایش شدن یک پیغام در ترد، از طریق این رویداد به اعضای آن ترد اطلاع داده می‌شود.
 ,MESSAGE_DELIVERY: دریافت پیام توسط گیرنده توسط این رویداد به فرستنده اطلاع رسانی می‌شود.
 ,MESSAGE_SEEN: پس از دیده شدن پیغام توسط کاربر گیرنده‌ی پیام ، فرستنده توسط این رویداد از این امر مطلع می‌شود.

**۲- threadEvents:**

تمامی رویدادهای تردهایی که کاربر در آن عضو است یا به آن مرتبط می‌باشد از این طریق اعلام می‌شود. رویدادهای مربوط به ترد، انواع زیر را داراست که بسته به نوع آن می‌توانید عملیات متناسب را سمت اپلیکیشن خود انجام دهید.

, THREAD_NEW: ساخت ترد جدید را به اعضایی که در آن مشارکت خواهند داشت (Participants) اعلام می‌کند.
 ,THREAD_LAST_ACTIVITY_TIME: زمانی که فعل و انفعالی در یک ترد رخ دهد، زمان آخرین فعل و انفعال رخ داده به اعضای آن ترد اعلام خواهد شد. (اپلیکیشن جهت آپدیت لیست تردها بر اساس جدیدترین تغییرات آنها می‌تواند اقدام کند)
 ,THREAD_ADD_PARTICIPANTS: اضافه شدن فرد جدید به یک ترد را به همه ی اعضا اعلام می‌کند.
 ,THREAD_LEAVE_PARTICIPANTS: ترک کردن ترد توسط یک فرد را به اعضا اعلام می‌کند.
 ,THREAD_REMOVE_PARTICIPANTS: حذف شدن یک فرد از ترد را به اعضا اعلام می‌کند.
, THREAD_REMOVED_FROM: حذف شدن یک فرد از ترد را به او اعلام می‌کند.
 ,THREAD_RENAME: تغییر نام ترد توسط این رویداد به هر یک از اعضا اعلام می‌شود.
 ,THREAD_MUTE: پس از غیرفعال کردن نوتیفیکیشن یک ترد توسط کاربر به او اعلام می‌شود.
 ,THREAD_UNMUTE: پس از فعال کردن نوتیفیکیشن یک ترد توسط کاربر به او اعلام می‌شود.
, THREAD_INFO_UPDATED: در صورتی که اطلاعات داخل ترد نیاز به به روز رسانی داشته باشد (مثل زمانی که یک پیغام پاک میشود)، توسط این رویداد به دیگر اعضا اطلاع رسانی می‌شود.
 ,THREAD_UNREAD_COUNT_UPDATED: تعداد پیغام‌های خوانده نشده‌ی هر ترد توسط این رویداد به اعضای آن اعلام می‌شود.اپلیکیشن می‌تواند در لیست تردهای نمایش داده به کاربر، تعداد پیغام‌های خوانده نشده‌ی هر کدام را اعلام کند.در صورتی که پیغام جدیدی به هر تردی اضافه شود ، تعداد پیغام‌های خوانده نشده‌ی آن آپدیت و بدین وسیله به کاربر (اعضای آن ترد) گزارش می‌شود.

```
/**
 * Listen to Thread Events
 */
Chat.on("threadEvents", function(event) {
  var type = event.type;

  switch (type) {
    case "THREAD_LAST_ACTIVITY_TIME":
      //your_code_here
      break;

    case "THREAD_NEW":
      //your_code_here
      break;

    case "THREAD_ADD_PARTICIPANTS":
      //your_code_here
      break;

    case "THREAD_REMOVE_PARTICIPANTS":
      //your_code_here
      break;

    case "THREAD_LEAVE_PARTICIPANT":
      //your_code_here
      break;

    case "THREAD_REMOVED_FROM":
      //your_code_here
      break;

    case "THREAD_RENAME":
      //your_code_here
      break;

    case "THREAD_MUTE":
      //your_code_here
      break;

    case "THREAD_UNMUTE":
      //your_code_here
      break;

    case "THREAD_INFO_UPDATED":
      //your_code_here
      break;

    case "THREAD_UNREAD_COUNT_UPDATED":
      //your_code_here
      break;

    default:
      break;
  }
});

```




**۳- error:**

تمامی خطا ها از سمت سرور توسط این رویداد به کاربر گزارش می‌شود.

```
/**
* Listen to Error Messages
*/
Chat.on("error", function(error) {
  console.log("ERROR \t", error.code, error.message, error.error);
});

```




**۴- chatState:**

تغییر وضعیت ارتباط با سرور پیام‌رسان را به کاربر اطلاع می‌دهد.

چهار وضعیت CONNECTED,CONNECTING,CLOSED,CLOSING قابل رخداد است.

```
/**
\* Listen to Chat State Changes
\*/
chatAgent.on("chatState", function(chatState) {
// your_code
});

```



<div class="box-end">
</div>

## آدرس‌ها و تنظیمات

تنظیمات و آدرس‌های زیر (برای سرور سندباکس) ، باید به عنوان پارامتر ورودی در هنگام ساخت نمونه ی اولیه از پکیج داده شود.

```
var params = {
    appId: new Date().getTime(),
    socketAddress: 'ws://172.16.110.131:8003/ws', // {**REQUIRED**} Socket Address
    ssoHost: 'http://172.16.110.76', // {**REQUIRED**} Socket Address
    platformHost: 'http://172.16.110.131:8080', // {**REQUIRED**} Platform Core Address
    fileServer: 'http://172.16.110.131:8080', // {**REQUIRED**} File Server Address
    serverName: 'chat-server2', // {**REQUIRED**} Server to to register on
    grantDeviceIdFromSSO: false,
    enableCache: false, // Enable Client side caching
    fullResponseObject: true,
    mapApiKey: 'NESHAN_MAP_API_KEY',
    typeCode: "default",
    token: '7cba09ff83554fc98726430c30afcfc6', // {**REQUIRED**} SSO Token 
    wsConnectionWaitTime: 500, // Time out to wait for socket to get ready after open
    connectionRetryInterval: 5000, // Time interval to retry registering device or registering server
    connectionCheckTimeout: 10000, // Socket connection live time on server
    messageTtl: 24 * 60 * 60, // Message time to live (1 day in seonds)
    reconnectOnClose: true, // auto connect to socket after socket close
    asyncLogging: {
        onFunction: true, // log main actions on console
        onMessageReceive: true, // log received messages on console
        onMessageSend: true, // log sent messaged on console
        actualTiming: true // log actual functions running time
    }
}

```


<div class="box-end">
</div>

## نصب - iOS

پکیج iOS چت را می‌توانید با استفاده از لینک زیر، از گیت هاب دریافت کنید.

لینک گیت‌هاب:

https://github.com/smartPodLand/Pod-Chat-iOS-SDK 

**راهنمای نصب و استفاده در Xcode**

پروژه‌ی خود را در Xcode باز کنید.

پکیج دانلود شده را روی پروژه‌ی خود، بصورت drag and drop بکشید.

دقت کنید که تیک گزینه‌ی Copy items if needed رو فعال کرده، سپس Finish را بزنید.

در قسمت Navigator ، پروژه‌ی خود را انتخاب کنید.

تب Build Phases را باز کنید.

منوی Link Binary With Libraries را انتخاب کنید.

گزینه‌ی + را کلیک کنید.

پکیج Chat.framework را پیدا کرده و Add کنید.

دقت کنید که باید دستور زیر را در ابتدای سورس کد خود اضافه کنید:

```
import FanapPodChatSDK

```




**پیش نیازها:**

ابتدا باید اجازه‌ی دسترسی درخواست‌های HTTP به به اپلیکیشن داده شود.

Navigator -> Info.plist (right-click) -> Open As -> Source Code

حالا کد زیر را اضافه کرده و به جای عبارت “YourDomainName” ، آدرس دامین خود را (که درخواست های HTTP به آن زده می‌شوند) جایگذاری کنید.

```
<key>NSAppTransportSecurity</key>
    <dict>
	<key>NSAllowsArbitraryLoads</key>
	<true/>
	<key>NSExceptionDomains</key>
	<dict>
	    <key>YourDomainName</key>
	    <dict>
		<key>NSExceptionAllowsInsecureHTTPLoads</key>
		<true/>
		<key>NSIncludesSubdomains</key>
		<true/>
	    </dict>
	</dict>
    </dict>

```




هر کاربر جهت ورود نیازمند به یک توکن دسترسی است.

توکن دسترسی باید قبل از استفاده از پکیج چت، از سرور sso دریافت شود تا هنگام ساخت نمونه ی اولیه از شیء چت، به عنوان پارامتر به آن داده شود.

**ساخت نمونه اولیه:**

اولین قدم، ساخت یک شیء ، از ماژول چت است.

ابتدا یک property برای نگهداری شیء از چت می‌سازید:

var myChatObject: Chat?

سپس چت را با استفاده از پارامتر‌های ورودی مورد نیاز (آدرس ها و تنظیمات) بسازید:

```
myChatObject = Chat(پارامتر های ورودی مورد نیاز را در این جا باید قرار دهید)

```




مثال:

```
myChatObject = Chat(socketAddress:		String,		// Socket Address
                     ssoHost:			String,		// SSO Host Address
                     platformHost:		String,		// PlatForm Address
                     fileServer:		String,		// File Server Address
                     serverName:		String,		// name of your chat server
                     token:			String,		// user TOKEN
                     mapApiKey:			String?,	// 
                     mapServer:			String,		// Map Server Address
                     typeCode:			String?,	// 
                     enableCache:		Bool,		// Do you want to use cache?
                     cacheTimeStampInSec:	Int?,		// How long does the participant objects lives on the Cache
                     msgPriority:		Int?,		//
                     msgTTL:			Int?,		//
                     httpRequestTimeout:	Int?,		//
                     actualTimingLog:		Bool?,		//
                     wsConnectionWaitTime:	Double,		//
                     connectionRetryInterval:	Int,		//
                     connectionCheckTimeout:	Int,		//
                     messageTtl:		Int,		//
                     reconnectOnClose:		Bool)		// Do you want to reconnect if connection lost?

```




بعد از ساختن چت، باید ChatDelegates را به انتهای تعریف کلاس خود اضافه کنید.

سپس این خط را به کد خود اضافه کنید:

```
myChatObject?.delegate = self

```




حالا باید متدهای ضروری ChatDelegates را پیاده‌سازی کنید:

```
func chatConnected() {
        // do your implementation
    }

    func chatReconnect() {
        // do your implementation 
    }

    func chatThreadEvents() {
        // do your implementation
    }

    func chatReady() {
        // do your implementation 
    }

    func chatError(errorCode: Int, errorMessage: String, errorResult: Any?) {
        // do your implementation
    }

    func chatState(state: Int) {
        // do your implementation
    }

    func chatDeliver(messageId: Int, ownerId: Int) {
        // do your implementation
    }

    func messageEvents(type: String, result: JSON) {
        // do your implementation
    }

    func threadEvents(type: String, result: JSON) {
        // do your implementation
    }

```


<div class="box-end">
</div>

## مدیریت پروفایل

**۱- getUserInfo:**

این متد اطلاعات پروفایل کاربر را در اختیارش قرار می‌دهد.

_ورودی:_

با توجه به توکن دسترسی عمل می‌کند، لذا نیازی به ورودی ندارد.

_خروجی:_

در خروجی این متد، ۳ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، جواب سرور به درخواست کاربر را بصورت مدل UserInfoModel بازمی‌گرداند.

سومی هم جواب بلادرنگی است که از Cache بازگشت داده می‌شود.

مثالی از فراخوانی این متد:

```
// Request
// an example of getUserInfo request:

// this is the model that you have to create to pass it through the "getUserInfo" method
Chat.sharedInstance.getUserInfo(uniqueId: { (getUserInfoUniqueId) in
  // "getContactUniqueId" is uniqueId of this request, that sends back to the client as a callback
  // do whatever you want with this unique Id

}, completion: { (userInfoServerResponse) in
  // this response is of type "UserInfoModel" but you have to froce cast it as below
  let myResponseModel: UserInfoModel = userInfoServerResponse as! UserInfoModel

}, cacheResponse: { (userInfoCacheResponse) in
  // this it the cache response of this request
  // output of this response, is of type "UserInfoModel". (there is no need to cast is as sth...)
})

```


<div class="box-end">
</div>

## مدیریت مخاطبین

**۱- getContacts:**

دریافت لیست مخاطبین.

این متد یک لیست جهت تنظیمات صفحه‌بندی (حداکثر تعداد مخاطبین در هر درخواست و شماره ی  شروع) دریافت می‌کند و لیست تمامی مخاطبین کاربر را بازمی‌گرداند.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس GetContactsRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد getContacts . 

_خروجی:_

در خروجی این متد، ۳ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، لیست تمامی مخاطبین کاربر را بصورت مدل GetContactsModel بازمی‌گرداند.

سومی، جواب بلادرنگی است که کاربر درصورت فعال کردن گزینه‌ی استفاده از Cache، از دیتابیس داخلی خود دریافت می‌کند. (بعد از دریافت جواب سرور، این دیتابیس بصورت خودکار آپدیت می‌شود)

مثالی از فراخوانی این متد:

```
// Request
// an example of getContact request:

// this is the model that you have to create to pass it through the "getContacts" method
let inputModel = GetContactsRequestModel(count:     5,    //
                                         offset:    0,    //
                                         query:     nil,  //
                                         typeCode:  nil,  //
                                         uniqueId:  nil)  //

Chat.sharedInstance.getContacts(getContactsInput: inputModel, uniqueId: { (getContactUniqueId) in
  // "getContactUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (getContactsServerResponse) in
  // this response is of type "GetContactsModel" but you have to froce cast it as below
  let myResponseModel: GetContactsModel = getContactsResponse as! GetContactsModel

}, cacheResponse: { (getContactsCacheResponse) in
  // this it the cache response of this request
  // output of this response, is of type "GetContactsModel". (there is no need to cast is as sth...)
})

```




**۲- searchContact:**

جستجو در لیست مخاطب ها.

با دریافت پارامترهای زیر، از بین مخاطبین کاربر به جستجو پرداخته و لیستی از مخاطبین با مشخصات داده شده را بازمی‌گرداند.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس SearchContactsRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد searchContacts .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، پاسخ درخواست جستجو مخاطب ها را بصورت مدل GetContactsModel بازمی‌گرداند.

سومی، جواب بلادرنگی است که کاربر درصورت فعال کردن گزینه ی استفاده از Cache، از دیتابیس داخلی خود دریافت می‌کند. (بعد از دریافت جواب سرور، این دیتابیس بصورت خودکار آپدیت می‌شود)

مثالی از فراخوانی این متد:

```
// Request
// an example of searchContact request:

// this is the model that you have to create to pass it through the "searchContact" method
let inputModel = SearchContactsRequestModel(cellphoneNumber: "09368640180", //
                                            email:            nil,	        //
                                            firstName:        nil,	        //
                                            id:               nil,	        //
                                            lastName:         nil,	        //
                                            offset:           nil,	        //
                                            size:             nil,	        //
                                            uniqueId:         nil)	        //

Chat.sharedInstance.searchContacts(searchContactsInput: inputModel, uniqueId: { (searchContactsUniqueId) in
	// "searchContactsUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (serverResponse) in
	// this response is of type "GetContactsModel" but you have to froce cast it as below
	let myResponseModel: GetContactsModel = serverResponse as! GetContactsModel

}, cacheResponse: { (cacheResponse) in
	// this it the cache response of this request
	// output of this response, is of type "GetContactsModel". (there is no need to cast is as sth...)
})

```




**۳- addContact:**

اضافه کردن مخاطب جدید.

این متد با دریافت نام ، نام خانوادگی ، شماره تماس و ایمیل، مخاطب جدیدی را ذخیره خواهد کرد.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس AddContactsRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد addContacts .

نکته: برای ساختن مدل AddContactsRequestModel، در صورت ارسال مقدار پارامتر firstName برای مخاطب، اجباری به ورود پارامتر نام خانوادگی(و بالعکس) نمی باشد؛ و هم چنین در صورت ورود شماره موبایل، ورود ایمیل الزامی نیست (و بالعکس).

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی هم، جواب درخواست ساخت مخاطب جدید را بصورت مدل ContactModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of addContact request:

// this is the model that you have to create to pass it through the "addContacts" method
let inputModel = AddContactsRequestModel(cellphoneNumber:  "0935****350", //
                                         email:            nil,           // 
                                         firstName:        "Mahyar",      //
                                         lastName:         "Akbarian",    //
                                         uniqueId:         nil)           //

Chat.sharedInstance.addContact(addContactsInput: inputModel, uniqueId: { (addContactUniqueId) in
	// "addContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (myResponse) in
	// this response is of type "ContactModel" but you have to froce cast it as below
	let myResponseModel: ContactModel = addContactResponse as! ContactModel
})

```




**۴- updateContact:**

آپدیت کردن اطلاعات مخاطب.

مشخصات جدید کاربر را به همرا id (همان آیدی مخاطب که پس از ذخیره ، یا به هنگام استفاده از سرویس لیست مخاطبین دریافت کرده اید) در لیست پارامتر ورودی به این متد بدهید تا عملیات تغییر مشخصات مخاطب مورد نظر صورت گیرد. پاسخ مشابه سرویس قبلی (AddContact) خواهد بود.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس UpdateContactsRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد updateContacts .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی هم، جواب درخواست ساخت مخاطب جدید را بصورت مدل ContactModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of updateContact request:

// this is the model that you have to create to pass it through the "updateContacts" method
let inputModel = UpdateContactsRequestModel(cellphoneNumber:  "0935****233",    //
                                            email:            "mehyar@me.com",  //
                                            firstName:        "Sina",           //
                                            id:               10,               //
                                            lastName:         "Rokni",          //
                                            uniqueId:         nil)              //

Chat.sharedInstance.updateContact(updateContactsInput: inputModel, uniqueId: { (updateContactUniqueId) in
	// "updateContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (updateContactResponse) in
	// this response is of type "ContactModel" but you have to froce cast it as below
	let myResponseModel: ContactModel = updateContactResponse as! ContactModel
})

```




**۵- removeContact:** 

حذف کردن یک مخاطب.

با دریافت آیدی مخاطب، آن مخاطب را حذف می‌کند.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس RemoveContactsRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد removeContact .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی هم پاسخ درخواست پاک کردن مخاطب را بصورت مدل RemoveContactModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of removeContact request:

// this is the model that you have to create to pass it through the "removeContacts" method
let inputModel = RemoveContactsRequestModel(id:        4121,  // id of your contact that you want to remove it
                                            uniqueId:  nil)   // 

Chat.sharedInstance.removeContact(removeContactsInput: inputModel, uniqueId: { (removeContactUniqueId) in
	// "removeContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (removeContactResponse) in
	// this response is of type "RemoveContactModel" but you have to froce cast it as below
	let myResponseModel: RemoveContactModel = removeContactResponse as! RemoveContactModel
})

```




**۶-block:**

بلاک کردن یک مخاطب یا یک ترد.

با دریافت آیدی مخاطب(contactId)، آیدی یوزر(userId) یا تردآیدی(threadId) امکان ارتباط با او را مسدود می‌کند.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس BlockContactsRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد blockContact .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی هم پاسخ درخواست بلاک را بصورت مدل BlockedContactModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of blockContact request:

// this is the model that you have to create to pass it through the "blockContacts" method
let inputModel = BlockContactsRequestModel(contactId:  81,   //
                                           threadId:   nil,  //
                                           typeCode:   nil,  //
                                           userId:     nil,  //
                                           uniqueId:   nil)  //

Chat.sharedInstance.blockContact(blockContactsInput: inputModel, uniqueId: { (blockContactUniqueId) in
	// "blockContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (blockContactResponse) in
	// this response is of type "BlockedContactModel" but you have to froce cast it as below
	let myResponseModel: BlockedContactModel = blockContactResponse as! BlockedContactModel
})``

```




**۷- getBlockContactList:**

لیست مخاطب‌های بلاک شده را باز می‌گرداند.

با پر کردن مقادیر ورودی count و offset می‌توانید تنظیمات صفحه‌بندی را اعمال کنید.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس GetBlockedContactListRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد getBlockedContacts .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی هم  لیست مخاطب‌های بلاک شده را بصورت مدل GetBlockedContactListModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of getBlockedList request:

// this is the model that you have to create to pass it through the "getBlockedContacts" method
let inputModel = GetBlockedContactListRequestModel(count:     nil,   //
                                                   offset:    nil,   //
                                                   typeCode:  nil,   //
                                                   uniqueId:  nil)   //

Chat.sharedInstance.getBlockedContacts(getBlockedContactsInput: inputModel, uniqueId: { (getBlockedContactListUniqueId) in
	// "getBlockedContactListUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (bockedListResponse) in
	// this response is of type "GetBlockedContactListModel" but you have to froce cast it as below
	let myResponseModel: GetBlockedContactListModel = bockedListResponse as! GetBlockedContactListModel
})

```




**۸-unblock:**

بیرون آوردن مخاطب

با دریافت بلاک آیدی blockId (آیدی مخاطب از لیست مسدود شده ها)، یا آیدی مخاطب (contactId)، یا آیدی یوزر (userId)، یا آیدی ترد (threadId) امکان ارتباط مجدد با مخاطب را برقرار می‌کند و مخاطب یا ترد، از لیست مسدود شده ها خارج می‌شود.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس UnblockContactsRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد unblockContact .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی هم پاسخ درخواست آن-بلاک را بصورت مدل BlockedContactModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of unblock request:

// this is the model that you have to create to pass it through the "unblockContact" method
let inputModel = UnblockContactsRequestModel(blockId:   141,	//
                                             contactId: nil,	//
                                             threadId:  nil,	//
                                             typeCode:  nil,	//
                                             userId:    nil,	//
                                             uniqueId:  nil)	//

Chat.sharedInstance.unblockContact(unblockContactsInput: inputModel, uniqueId: { (unblockContactUniqueId) in
	// "unblockContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (unblockResponse) in
	// this response is of type "BlockedContactModel" but you have to froce cast it as below
	let myResponseModel: BlockedContactModel = unblockResponse as! BlockedContactModel
})

```




**۹- syncContact:** 

همگام‌سازی مخاطب‌ها.

تمامی مخاطبین دستگاه را که در لیست مخاطبین اپلیکیشن شما نیستند ، به آن اضافه می‌کند.

_ورودی:_

این متد پارامتر ورودی ندارد.

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی هم پاسخ درخواست آن را بصورت مدل ContactModel بازمی‌گرداند.

```
// Request
// an example of syncContact request:

Chat.sharedInstance.syncContacts(uniqueId: { (syncContactUniqueId) in
	// "syncContactUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (myResponse) in
	// this response is of type "ContactModel" but you have to froce cast it as below
	let myResponseModel: ContactModel = myResponse as! ContactModel
})

```




**نکته:**

در تمامی متدهای ذکر شده در بالا، خروجی بصورت مدلی خواهد بود که شما می‌توانید‌ از آن استفاده کنید.

همچنین می توانید با فراخوانی متد ()returnDataAsJSON ، خروجی را بصورت JSON مشاهده کنید.

بطور مثال:

```
let myResponseJSON: JSON = myResponseModel.returnDataAsJSON()

```




------

در حال حاضر، برای ارسال پارامترهای ورودی به متدهای مورد نظر، به جز روشی که می‌توانید با ساخت مدل مربوطه به هر درخواست، این کار را انجام دهید، روش دیگری نیز وجود دارد که می‌توانید  یک فایل JSON را بعنوان پارامترهای ورودی مورد نظر خود به متد مربوطه پاس دهید.

نکته: در خروجی متدی که پارامترهای ورودی را بصورت JSON میدهید، خروجی Cache به شما برنمی‌گردد!

نکته: ترجیح بر این است که از حالت اول (ساختن مدل ورودی) استفاده کنید که در بالا بصورت جزء به جزء توضیح داده شده.

نکته: توجه داشته باشید که احتمالا در آینده ی نزدیک، استفاده از JSON برای پرکردن پارامترهای ورودی deprecate اعلام خواهد شد.

<div class="box-end">
</div>

## مدیریت تردها

**۱- getThreads:**

لیست تمام تردهای اخیرا ایجاد شده‌ی کاربر را به ترتیب زمانی و بر اساس متغیرهای صفحه‌بندی (count, offset) نشان خواهد داد.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس GetThreadsRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد getThreads .

_خروجی:_

در خروجی این متد، ۳ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، لیست تمامی تردهای موجود کاربر را بصورت مدل GetThreadsModel بازمیگرداند (با توجه به پارامترهای ارسالی).

سومی، جواب بلادرنگی است که کاربر درصورت فعال کردن گزینه‌ی استفاده از Cache، از دیتابیس داخلی خود دریافت می‌کند. (بعد از دریافت جواب سرور، این دیتابیس بصورت خودکار آپدیت می‌شود)

مثالی از فراخوانی این متد:

```
// Request
// an example of getThreads request:

// this is the model that you have to create to pass it through the "getThreads" method
let inputModel = GetThreadsRequestModel(count:                 9,    //
                                        creatorCoreUserId:     nil,  //
                                        metadataCriteria:      nil,  //
                                        name:                  nil,  //
                                        new:                   nil,  //
                                        offset:                0,    //
                                        partnerCoreContactId:  nil,  //
                                        partnerCoreUserId:     nil,  //
                                        threadIds:             nil,  //
                                        typeCode:              nil,  //
                                        uniqueId:              nil)  //

Chat.sharedInstance.getThreads(getThreadsInput: inputModel, uniqueId: { (getThreadUniqueId) in
  // "getThreadUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (getThreadServerResponse) in
  // this response is of type "GetThreadsModel" but you have to froce cast it as below
  let myResponseModel: GetThreadsModel = getThreadServerResponse as! GetThreadsModel

}, cacheResponse: { (getThreadCacheResponse) in
  // this it the cache response of this request
  // output of this response, is of type "GetThreadsModel". (there is no need to cast is as sth...)
})

```




**۲- updateThreadInfo:**

با فراخوانی این متد می‌توانید مشخصات یک ترد را تغییر دهید.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس UpdateThreadInfoRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد updateThreadInfo .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، جواب سرور به این ریکوئست را بصورت مدل GetThreadsModel برمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of updatrThreadInfo request:

// this is the model that you have to create to pass it through the "createThread" method
let inputModel = UpdateThreadInfoRequestModel(description:  nil,         //
                                              image:        nil,         //
                                              metadata:     nil,         //
                                              threadId:     1113,        //
                                              title:        "newTitle",  //
                                              typeCode:     nil,         //
                                              uniqueId:     nil)         //

Chat.sharedInstance.updateThreadInfo(updateThreadInfoInput: inputModel, uniqueId: { (updateThreadInfoUniqueId) in
  // "updateThreadInfoUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (updateThreadResponse) in
  // this response is of type "GetThreadsModel" but you have to froce cast it as below
  let myResponseModel = updateThreadResponse as! GetThreadsModel
})

```




**۳- createThread:**

ساخت یک ترد ، شامل ساخت ترد نفر به نفر (چت دو نفره) ، یا ترد جمعی (گروه) می‌باشد. در حالت عادی نحوه‌ی ایجاد هر دو مدل یکسان است ، تفاوت در تعداد نفرات گروه نسبت به ترد دو نفره میباشد.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس CreateThreadRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد createThread .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی پاسخ سرور به درخواست کاربر را بصورت مدل CreateThreadModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of createThread request:

// this is the model that you have to create to pass it through the "createThread" method
let inviteeArray: [Invitee] = [Invitee(id:      "099****27",                                    //
                                       idType:  InviteeVOidTypes.TO_BE_USER_CELLPHONE_NUMBER)]  //

let inputModel = CreateThreadRequestModel(description:  nil,                 //
                                          image:        nil,                 //
                                          invitees:     inviteeArray,        //
                                          metadata:     nil,                 // 
                                          title:        "New Group",         //
                                          type:         ThreadTypes.NORMAL,  //
                                          uniqueId:     nil)                 //

Chat.sharedInstance.createThread(createThreadInput: inputModel, uniqueId: { (createThreadUniqeuId) in
  // "createThreadUniqeuId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (myCreateThreadResponse) in
  // this response is of type "CreateThreadModel" but you have to froce cast it as below
  let myResponseModel: CreateThreadModel = myCreateThreadResponse as! CreateThreadModel
})

```




**۴- createThreadWithMessage:**

ساخت یک ترد ، شامل ساخت ترد نفر به نفر (چت دو نفره) ، یا ترد جمعی (گروه) وهمچنین ارسال همزمان مسیج می‌باشد.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس CreateThreadWithMessageRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد createThread .

_خروجی:_

در خروجی این متد، ۵ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، لیست تمامی مسیج‌های کاربر را بصورت مدل CreateThreadModel بازمی‌گرداند.

سومی، پیغام sent شدن مسیج می‌باشد (از نوع SendMessageModel) که از سمت سرور برمی‌گردد.

چهارمی، پیغام deliver شدن مسیج می‌باشد (از نوع SendMessageModel) که از سمت سرور برمی‌گردد.

پنجمی، پیغام seen شدن مسیج می‌باشد (از نوع SendMessageModel) که از سمت سرور برمی‌گردد.

مثالی از فراخوانی این متد:

```
// Request
// an example of creatThreadWithMessage request:

// this is the model that you have to create to pass it through the "creatThreadWithMessage" method
let inviteeArray: [Invitee] = [Invitee(id:      "099****27",                                    //
                                       idType:  InviteeVOidTypes.TO_BE_USER_CELLPHONE_NUMBER)]  //

let inputModel = CreateThreadWithMessageRequestModel(threadDescription:           nil,                         //
                                                     threadImage:                 nil,                         //
                                                     threadInvitees:              inviteeArray,                //
                                                     threadMetadata:              nil,                         //
                                                     threadTitle:                 "title",                     //
                                                     threadType:                  ThreadTypes.NORMAL,          //
                                                     messageForwardedMessageIds:  nil,                         //
                                                     messageForwardedUniqueIds:   nil,                         //
                                                     messageMetaData:             nil,                         //
                                                     messageRepliedTo:            nil,                         //
                                                     messageSystemMetaData:       nil,                         //
                                                     messageText:                 "This is The Message Text",  //
                                                     messageType:                 nil,                         //
                                                     uniqueId:                    nil)                         //

Chat.sharedInstance.creatThreadWithMessage(creatThreadWithMessageInput: inputModel, uniqueId: { (createWithSendMessageUniqeuId) in
  // "createThreadUniqeuId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (createThreadResponse) in
  // this response is of type "CreateThreadModel" but you have to froce cast it as below
  let myResponseModel: CreateThreadModel = createThreadResponse as! CreateThreadModel

}, onSent: { (isSent) in
  // when the message sends successfully, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let sentModel: SendMessageModel = isSent as! SendMessageModel

}, onDelivere: { (isDeliver) in
  // when the message is delivered, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let deliverModel: SendMessageModel = isDeliver as! SendMessageModel

}, onSeen: { (isSeen) in
  // when the message is seen, this response of type "SendMessageModel" comes that you have to froce cast it as below
  let seenModel: SendMessageModel = isSeen as! SendMessageModel
})

```




**۵- leaveThread:**

با دریافت آیدی ترد ، کاربر را از ترد مربوطه خارج می‌کند.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس LeaveThreadRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد leaveThread .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، نتیجه ترک ترد را بصورت مدل CreateThreadModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of leaveThread request:

// this is the model that you have to create to pass it through the "leaveThread" method
let inputModel = LeaveThreadRequestModel(content:   nil,   //
                                         threadId:  1343,  //
                                         typeCode:  nil,   //
                                         uniqueId:  nil)   //

Chat.sharedInstance.leaveThread(leaveThreadInput: inputModel, uniqueId: { (leaveThreadUniqueId) in
	// "leaveThreadUniqueId" is uniqueId of this request, that sends back to client as a callback
	// do whatever you want with this unique Id

}, completion: { (leaveThreadResponse) in
	// this response is of type "CreateThreadModel" but you have to froce cast it as below
	let myResponseModel: CreateThreadModel = leaveThreadResponse as! CreateThreadModel
})

```




**۶- spamPvThread:**

با دریافت آیدی مربوط به یک ترد ، آن ترد را اسپم می‌کنم.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس SpamPvThreadRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد spamPvThread .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، جواب سرور به این ریکوئست را ۳ بار بصورت زیر برمی‌گرداند:

 "ThreadModel" (بابت ترک ترد)، ‌BlockModel (بابت بلاک کردن ترد)، ClearHistoryModel (بابت پاک کردن چت‌های داخل ترد) 

مثالی از فراخوانی این متد:

```
// Request
// an example of spamPvThread request:

// this is the model that you have to create to pass it through the "spamPvThread" method
let inputModel = SpamPvThreadRequestModel(threadId:  2,    //
                                          typeCode:  nil,  //
                                          uniqueId:  nil)  //

Chat.sharedInstance.spamPvThread(spamPvThreadInput: inputModel, uniqueId: { (spamPvThreadUniqueId) in
  // "spamPvThreadUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (spamThreadResponse) in

  // this response is of type "ThreadModel" that you have to froce cast it as below
  if let leaveThreadResponse = spamThreadServerResponseModel as? ThreadModel {
    self.responseCallback?(leaveThreadResponse)

  // this response is of type "BlockedContactModel" that you have to froce cast it as below
  } else if let blockThreadResponse = spamThreadServerResponseModel as? BlockedContactModel  {
    self.responseCallback?(blockThreadResponse)

  // this response is of type "ClearHistoryModel" that you have to froce cast it as below
  } else if let clearHistoryResponse = spamThreadServerResponseModel as? ClearHistoryModel {
    self.responseCallback?(clearHistoryResponse)
  }

})

```




**۷- muteThread:**

با دریافت آیدی ترد ، ترد مربوطه را mute می‌کند.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس MuteAndUnmuteThreadRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد muteThread .

خروجی:

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، جواب سرور به این ریکوئست را بصورت مدل MuteUnmuteThreadModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of muteThread request:

// this is the model that you have to create to pass it through the "muteThread" method
let inputModel = MuteAndUnmuteThreadRequestModel(subjectId:  1101,  //
                                                 typeCode:   nil,   //
                                                 uniqueId:   nil)   //

Chat.sharedInstance.muteThread(muteThreadInput: inputModel, uniqueId: { (muteThreadUniqueId) in
  // "muteThreadUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (muteThreadResponse) in
  // this response is of type "MuteUnmuteThreadModel" but you have to froce cast it as below
  let myResponseModel: MuteUnmuteThreadModel = muteThreadResponse as! MuteUnmuteThreadModel
})

```




**۸- unmuteThread:**

با دریافت آیدی ترد  ، مشخصه‌ی mute ترد مربوطه را در صورت فعال بودن ، غیرفعال می‌کند.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس MuteAndUnmuteThreadRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد unmuteThread .

خروجی:

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، جواب سرور به این ریکوئست را بصورت مدل MuteUnmuteThreadModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of unmuteThread request:

// this is the model that you have to create to pass it through the "unmuteThread" method
let inputModel = MuteAndUnmuteThreadRequestModel(subjectId: 1101,   //
                                                 typeCode:   nil,   //
                                                 uniqueId:   nil)   //

Chat.sharedInstance.unmuteThread(unmuteThreadInput: inputModel, uniqueId: { (unmuteThreadUniqueId) in
  // "unmuteThreadUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (unmuteThreadResponse) in
  // this response is of type "MuteUnmuteThreadModel" but you have to froce cast it as below
  let myResponseModel: MuteUnmuteThreadModel = unmuteThreadResponse as! MuteUnmuteThreadModel
})

```




**۹- getThreadParticipants:**

اعضای یک ترد با توجه به پارامترهای ورودی، نشان می‌دهد.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس GetThreadParticipantsRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد getThreadParticipants .

_خروجی:_

در خروجی این متد، ۳ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، لیست تمامی اعضای یک ترد را بصورت مدل GetThreadParticipantsModel بازمی‌گرداند.

سومی، جواب بلادرنگی است که کاربر درصورت فعال کردن گزینه ی استفاده از Cache، از دیتابیس داخلی خود دریافت می‌کند. (بعد از دریافت جواب سرور، این دیتابیس بصورت خودکار آپدیت می‌شود)

مثالی از فراخوانی این متد:

```
// Request
// an example of getThreadParticipants request:

// this is the model that you have to create to pass it through the "getThreadParticipants" method
let inputModel = GetThreadParticipantsRequestModel(admin:           nil,   //
                                                   count:           5,     //
                                                   firstMessageId:  nil,   //
                                                   lastMessageId:   nil,   //
                                                   name:            nil,   //
                                                   offset:          0,     //
                                                   threadId:        1330,  //
                                                   typeCode:        nil,   //
                                                   uniqueId:        nil)   //

Chat.sharedInstance.getThreadParticipants(getThreadParticipantsInput: inputModel, uniqueId: { (getThreadParticipantUniqueId) in
  // "getThreadParticipantUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (threadParticipantsServerResponse) in
  // this response is of type "GetThreadParticipantsModel" but you have to froce cast it as below
  let myResponseModel: GetThreadParticipantsModel = threadParticipantsServerResponse as! GetThreadParticipantsModel

}, cacheResponse: { (threadParticipantsCacheResponse) in
  // this it the cache response of this request
  // output of this response, is of type "GetThreadParticipantsModel". (there is no need to cast is as sth...)
})

```




**۱۰- addParticipants:**

با دریافت آیدی ترد و لیستی از از آیدی مخاطبین (contact Id) ، آنها را به اعضای ترد مربوطه اضافه می‌کند.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس AddParticipantsRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد addParticipants .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، نتیجه ی اضافه کردن عضو به ترد را بصورت مدل AddParticipantModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of addParticipants request:

// this is the model that you have to create to pass it through the "addParticipants" method
let inputModel = AddParticipantsRequestModel(contacts:  [2202, 952, 1281, 2306],  //
                                             threadId:  1330,                     //
                                             typeCode:  nil,                      //
                                             uniqueId:  nil)                      //

Chat.sharedInstance.addParticipants(addParticipantsInput: inputModel, uniqueId: { (addParticipantsUniqueId) in
  // "addParticipantsUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (addParticipantsResponse) in
  // this response is of type "AddParticipantModel" but you have to froce cast it as below
  let response: AddParticipantModel = addParticipantsResponse as! AddParticipantModel
})

```




**۱۱- removeParticipants:**

با دریافت آیدی ترد و لیستی از آیدی کاربران (userId)، آن‌ها را از ترد مورد نظر حذف می‌کند.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس RemoveParticipantsRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد removeParticipants .

_خروجی:_

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، نتیجه ی حذف کردن عضو از ترد را بصورت مدل RemoveParticipantModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of removeParticipants request:

// this is the model that you have to create to pass it through the "removeParticipants" method
let inputModel = RemoveParticipantsRequestModel(contacts:  [1],   //
                                                threadId:  1330,  //
                                                typeCode:  nil,   //
                                                uniqueId:  nil)   //

Chat.sharedInstance.removeParticipants(removeParticipantsInput: inputModel, uniqueId: { (removeParticipantsUniqueId) in
  // "removeParticipantsUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (removeParticipantsResponse) in
  // this response is of type "RemoveParticipantModel" but you have to froce cast it as below
  let response: RemoveParticipantModel = removeParticipantsResponse as! RemoveParticipantModel
})

```




**۱۲- setRole:**

با دریافت آیدی ترد و همچنین آیدی یوزر، می‌تواند به یوزر رول‌های ادمین بدهد (یا برعکس، رول‌های ادمین را از یوزر بگیرد)

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساخت و ارسال آرایه‌ای از کلاس SetRoleRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد setRole .

خروجی:

در خروجی این متد، ۳ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، جواب سرور به این ریکوئست را بصورت مدل UserRolesModel بازمی‌گرداند.

سومی، جواب بلادرنگی است که کاربر درصورت فعال کردن گزینه‌ی استفاده از Cache، از دیتابیس داخلی خود دریافت می‌کند. (بعد از دریافت جواب سرور، این دیتابیس بصورت خودکار آپدیت می‌شود)

مثالی از فراخوانی این متد:

```
// Request
// an example of setRole request:

// this is the model that you have to create to pass it through the "setRole" method
let inputModel = SetRoleRequestModel(roles:           [Roles.CHANGE_THREAD_INFO, Roles.EDIT_MESSAGE_OF_OTHERS],  //
                                     roleOperation:   RoleOperations.Add,  //
                                     threadId:        1330,                //
                                     typeCode:        nil,                 //
                                     uniqueId:        nil,                 //
                                     userId:          2244)                //

Chat.sharedInstance.setRole(setRoleInput: [inputModel], uniqueId: { (setRoleUniqueId) in
  // "setRoleUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (setRoleServerResponse) in
  // this response is of type "UserRolesModel" but you have to froce cast it as below
  let myResponseModel = setRoleServerResponse as! UserRolesModel

}, cacheResponse: { (setRoleCacheResponse) in
  // this it the cache response of this request
  // output of this response is of type "UserRolesModel". (there is no need to cast is as sth...)
})

```




**۱۳- getHistory:**

با دریافت آیدی مربوط به یک ترد، تاریخچه‌ی آن را بر اساس تنظیمات صفحه‌بندی (count,offset) نشان خواهد داد.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس GetHistoryRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد getHistory .

_خروجی:_

در خروجی این متد، ۹ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، لیست تمامی مسیج‌های کاربر را بصورت مدل GetHistoryModel بازمی‌گرداند (با توجه به پارامترهای ارسالی).

سومی، جواب بلادرنگی است که کاربر درصورت فعال کردن گزینه‌ی استفاده از Cache، از دیتابیس داخلی خود دریافت می‌کند. (بعد از دریافت جواب سرور، این دیتابیس بصورت خودکار آپدیت می‌شود)

چهارمی، مسیج‌های متنی ارسالی که هنوز جوابشون از سمت سرور نیومده رو برمی‌گردونه.

پنجمی، مسیج‌های edit شده‌ی ارسالی که هنوز جوابشون از سمت سرور نیومده رو برمی‌گردونه.

ششمی، مسیج‌های forward شده‌ی ارسالی که هنوز جوابشون از سمت سرور نیومده رو برمی‌گردونه.

هفتمی، مسیج‌های همراه با ارسال فایل که هنوز جوابشون از سمت سرور نیومده یا هنوز آپلودشون کامل نشده رو برمی‌گردونه.

هشتمی، مسیج‌های آپلود عکس که هنوز جوابشون از سمت سرور نیومده یا هنوز آپلودشون کامل نشده رو برمی‌گردونه.

نهمی، مسیج‌های آپلود فایل که هنوز جوابشون از سمت سرور نیومده یا هنوز آپلودشون کامل نشده رو برمی‌گردونه.

مثالی از فراخوانی این متد:

```
// Request
// an example of getHistory request:

// this is the model that you have to create to pass it through the "getHistory" method
let inputModel = GetHistoryRequestModel(count:               2,    //
                                        firstMessageId:      nil,  //
                                        fromTime:            nil,  //
                                        lastMessageId:       nil,  //
                                        messageId:           nil,  //
                                        metadataCriteria:    nil,  //
                                        offset:              nil,  //
                                        order:               nil,  //
                                        query:               nil,  //
                                        threadId:            128,  //
                                        toTime:              nil,  //
                                        typeCode:            nil,  //
                                        uniqueId:            nil)  //

Chat.sharedInstance.getHistory(getHistoryInput: inputModel, uniqueId: { (getHistoryUniqueId) in
  // "getHistoryUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (getHistoryServerResponse) in
  // this response is of type "GetHistoryModel" but you have to froce cast it as below
  let myResponseModel: GetHistoryModel = getHistoryServerResponse as! GetHistoryModel

}, cacheResponse: { (getHistoryCacheResponse) in
  // this it the cache response of this request
  // output of this response, is of type "GetHistoryModel". (there is no need to cast is as sth...)

}, textMessagesNotSent: { ([QueueOfWaitTextMessagesModel]) in
  // this response contain all messages that has not sent yet!
  // you have to cast it as [QueueOfWaitTextMessagesModel]

}, editMessagesNotSent: { ([QueueOfWaitEditMessagesModel]) in
  // this response contain all edite messages that has not sent yet!
  // you have to cast it as [QueueOfWaitEditMessagesModel]

}, forwardMessagesNotSent: { ([QueueOfWaitForwardMessagesModel]) in
  // this response contain all forward messages that has not sent yet!
  // you have to cast it as [QueueOfWaitForwardMessagesModel]

}, fileMessagesNotSent: { ([QueueOfWaitFileMessagesModel]) in
  // this response contain all file messages that has not sent yet!
  // you have to cast it as [QueueOfWaitFileMessagesModel]

}, uploadImageNotSent: { ([QueueOfWaitUploadImagesModel]) in
  // this response contain all uploadImage requests that has not sent yet!
  // you have to cast it as [QueueOfWaitUploadImagesModel]

}, uploadFileNotSent: { ([QueueOfWaitUploadFilesModel]) in
  // this response contain all uploadFile requests that has not sent yet!
  // you have to cast it as [QueueOfWaitUploadFilesModel]
})

```




**۱۴- clearHistory:**

با دریافت آیدی ترد، تمامی مسیج‌های داخل ترد را پاک می‌کند.

_ورودی:_

برای پر کردن پارامترهای ورودی این متد، از روش زیر می‌توانید این کار را انجام دهید:

ساختن یک مدل از کلاس ClearHistoryRequestModel و پاس دادن آن بعنوان پارامتر ورودی به متد clearHistory .

خروجی:

در خروجی این متد، ۲ تا  completion handler داریم:

اولی، uniqueId این درخواست شما رو بصورت یک String برمی‌گرداند.

دومی، جواب سرور به این ریکوئست را بصورت مدل ClearHistoryModel بازمی‌گرداند.

مثالی از فراخوانی این متد:

```
// Request
// an example of clearHistory request:

// this is the model that you have to create to pass it through the "getHistory" method
let inputModel = ClearHistoryRequestModel(threadId:   1330,  //
                                          uniqueId:   nil)   //

Chat.sharedInstance.clearHistory(clearHistoryInput: clearHistoryInput, uniqueId: { (clearHistoryUniqueId) in
  // "clearHistoryUniqueId" is uniqueId of this request, that sends back to client as a callback
  // do whatever you want with this unique Id

}, completion: { (clearHistoryServerResponse) in
  // this response is of type "ClearHistoryModel" but you have to froce cast it as below
  let myResponseModel = clearHistoryServerResponse as! ClearHistoryModel
})

```




**نکته:**

در تمامی متدهای ذکر شده در بالا، خروجی بصورت مدل خواهد بود که شما می‌توانید از آن استفاده کنید.

همچنین می توانید با فراخوانی متد ()returnDataAsJSON ، خروجی را بصورت JSON مشاهده کنید.

بطور مثال:

```
let myResponseJSON: JSON = myResponseModel.returnDataAsJSON()

```


<div class="box-end">
</div>

## نصب- نسخه اندروید

پکیج اندرویدی چت را می‌توانید از لینک زیر با استفاده از گیت دریافت کنید یا فایل زیپ آن را دانلود نمایید.

لینک گیت هاب

**راهنمای نصب با استفاده از Android Studio:**

چت Sdk به صورت یک ماژول مستقل نیز از طریق maven  قابل دسترس است.

با اضافه کردن در app/build.gradle در قسمت dependencies می توانید نیز به پروژه ی خود اضافه کنید.

```
dependencies { 
implementation 'com.fanap.podchat:podchat:0.4.2.0' }

```




**پیش نیاز ها:**

- دسترسی اینترنت به اپلیکیشن باید داده شود. خط زیر را به فایل AndroidManifest.xml پروژه خود اضافه کنید:

  <uses-permission android:name="android.permission.INTERNET" />

هر کاربر جهت ورود نیازمند به یک توکن دسترسی است. 
توکن دسترسی باید قبل از استفاده از پکیج چت ، از سرور sso دریافت شود تا به هنگام ساخت نمونه‌ی اولیه از شیء چت به عنوان پارامتر به آن داده شود.

**ساخت نمونه اولیه:**

اولین قدم ساخت یک شیء نمونه از ماژول چت است.

```
chat.init(context);

```




سپس ارتباط با سرور مانند مثال زیر از طریق متد connect برقرار می‌شود.

```
\* @param requestConnect {
     \*                       socketAddress {**REQUIRED**}
     \*                       platformHost  {**REQUIRED**}
     \*                       severName     {**REQUIRED**}
     \*                       appId         {**REQUIRED**}
     \*                       token         {**REQUIRED**}
     \*                       fileServer    {**REQUIRED**}
     \*                       ssoHost       {**REQUIRED**}
     \*                       }
     \*/
RequestConnect requestConnect = new RequestConnect
                .Builder(serverAddress, appId, severName, token, ssoHost, platformHost, fileServer)
                .build();
        chat.connect(requestConnect);

```




آدرس‌ها و تنظیمات

در نهایت نمونه‌ی ساخته شده آماده‌ی استفاده است.

با قرار دادن true در لاگ به شما لاگ خام بدون تغییرات را نشان می‌دهد. توصیه می‌شود در هنگام توسعه این لاگ را فعال کنید.

```
chat.rawLog(boolean rawLog);

```




با قرار دادن مقدار زمانی که می‌خواهید هنگام فرستادن سیگنال‌هایی مانند _is_typing  هر چند ثانیه سینگال مخصوص را می‌فرستد.

```
	chat.signalIntervalTime(int Second)

```




قابلیت کش را فراهم می‌کند.

```
chat.isCacheables(boolean cache);

```




لاگ را برای تمام جواب‌ها و ریکویست ها نشان می‌دهد.

```
chat.isLoggable(boolean log);

```


<div class="box-end">
</div>

## مدیریت مخاطبین

**۱- getContacts:**
دریافت لیست مخاطبین. این متد یک لیست جهت تنظیمات صفحه‌بندی (حداکثر تعداد مخاطبین در هر درخواست و شماره ی  شروع) دریافت می‌کند و لیست تمامی مخاطبین کاربر را بازمی‌گرداند.

```
count = 50;
offset = 0;

 RequestGetContact requestGetContact = new RequestGetContact.Builder()
                .count()
                .offset()
                .build();
 chat.getContacts(requestGetContact,null);

```




**۲- addContact:**

با دریافت نام، نام خانوادگی، شماره تماس و ایمیل، مخاطب جدید ذخیره خواهد کرد.

نکته:
در صورت ارسال مقدار پارامتر firstName برای مخاطب، اجباری به ورود پارامتر نام خانوادگی (و بالعکس) نمی‌باشد و هم چنین در صورت ورود شماره موبایل، ورود ایمیل الزامی نیست(و بالعکس).

اما توجه داشته باشید ارسال مقادیر پارامتر(اگرچه بدون مقدار ورودی) الزامی می‌باشد.

```
  /**
 	\* Add one contact to the contact list
 	\*
 	\* @param request {
 	\*            	firstName   	Notice: if just put fistName without lastName its ok.
 	\*            	lastName    	last name of the contact
 	\*            	cellphoneNumber Notice: If you just  put the cellPhoneNumber doesn't necessary to add email
 	\*            	email       	email of the contact
 	\*            	}
 	\*/
   	  RequestAddContact requestAddContact = new RequestAddContact.Builder()
            	.firstName()
            	.lastName()
            	.cellphoneNumber()
            	.email()
            	.build();
    	chat.addContact(requestAddContact);

```




**۳- updateContact:**

مشخصات جدید کاربر را به همرا id (همان آیدی مخاطب که پس از ذخیره ، یا به هنگام استفاده از سرویس لیست مخاطبین دریافت کرده اید) در لیست پارامتر ورودی به این متد بدهید تا عملیات تغییر مشخصات مخاطب مورد نظر صورت گیرد. پاسخ مشابه سرویس قبلی خواهد بود. 

```
/**
 	\* Update contacts
 	\* All of the params all [Required]
 	\*
 	\* @param request {
 	\*             	String firstName [Required]
 	\*             	String lastName [Required]
 	\*             	String cellphoneNumber [Required]
 	\*             	String email [Required]
 	\*             	long userId [Required]
 	\*            	}
 	\*/
     RequestUpdateContact requestUpdateContact = new RequestUpdateContact.Builder(userId)
            	.firstName()
            	.lastName()
            	.cellphoneNumber()
            	.email()
            	.build();
    	chat.updateContact(updateContact);

```




**۴- removeContact:**

با دریافت آیدی مخاطب، مشخصات آن را از لیست مخاطبین حذف می‌کند.

```
/**
 	\* Remove contact with the user id
 	\*
 	\* @param request {
 	\*            	long userId
 	\*            	}
 	\*/
   	 RequestRemoveContact requestRemoveContact = new RequestRemoveContact.Builder(userId)
            	.build();
    	chat.removeContact(requestRemoveContact);

```




**۵- syncContact:** 

تمامی مخاطبین دستگاه را که در لیست مخاطبین اپلیکیشن شما نیستند ، به آن اضافه می‌کند.

```
 /**
 	\* First we get the contact from server then at the respond of that
 	\*
 	\* @param activity its for check the permission of reading the phone contact
 	\*             	{@link #getPhoneContact(Context)}
 	\*/
	chat.syncContact(Activity activity);

```




**۶-block:**

با دریافت آیدی مخاطب، ایدی ترد  و ایدی کاربری، امکان ارتباط با او را مسدود می‌کند.

```
/**
     \* It blocks the thread
     \* @ param contactId id of the contact
     \* @ param threadId  id of the thread
     \* @ param userId    id of the user
     \*/

	  RequestBlock requestBlock = new RequestBlock.Builder()
                .contactId()
                .threadId()
                .userId()
                .build();
        chat.block(requestBlock,null);

```




**۷-getBlockList:**

لیست مخاطبین بلاک شده را بازمی‌گرداند.

با پر کردن مقادیر ورودی count و offset می‌توانید تنظیمات صفحه‌بندی را اعمال کنید.

```
	  /**
 \* It gets the list of the block list
 \*
 \* @param request {
 \*                ----- long count Number of the response
 \*                ----- long offset offset of the response
 \*                }
 \* @param handler Its not useful yet set it to null
 \*/
    RequestBlockList requestBlockList = new RequestBlockList.Builder()
            .count()
            .offset()
            .build();
    chat.getBlockList(requestBlockList,null);

```




**۸-unblock:**

با دریافت blockId (آیدی مخاطب از لیست مسدود شده‌ها)، UserId , ContactId, ThreadId امکان ارتباط مجدد با مخاطب را برقرار می‌کند و مخاطب از لیست مسدود شده ها خارج می‌شود.

```
/**
     \* It unblocks thread with three way
     \*
     \* @ param blockId it can be found in the response of getBlockList
     \* @ param userId Id of the user
     \* @ param threadId Id of the thread
     \* @ param contactId Id of the contact
     \*/ 
RequestUnBlock requestUnBlock = new RequestUnBlock.Builder()
                .blockId()
                .contactId()
                .threadId()
                .userId()
                .build();
        chat.unblock(request, handler);

```




**۹- searchContact:**

با دریافت پارامترهای زیر، از بین مخاطبین کاربر به جستجو پرداخته و لیستی از مخاطبین با مشخصات داده شده را بازمی‌گرداند.

پارامترهای ضروری را با استفاده از builder مقداردهی می‌شوند ، همچنین هر یک از پارامتر های دلخواه را در صورت وجود به آن اضافه کرده و شیء ورودی متد را به کمک آن بسازید.

```
/*
\*cellphoneNumber
\*email
\*firstName
\*lastName
\*uniqueId
\*id
\*offset 
\*size 
\*typeCode
\*q
\*/

SearchContact searchContact = new SearchContact.Builder(string offset, string size).id(string id).build();

chat.searchContact(SearchContact searchContact);

```


<div class="box-end">
</div>

## مدیریت تردها

**۱- getThreads:**

لیست تمام تردهای اخیرا ایجاد شده‌ی کاربر را به ترتیب زمانی و بر اساس متغیرهای صفحه‌بندی (count, offset) نشان خواهد داد.

```
/**
     \*
     \* @param creatorCoreUserId    if it sets to '0' its considered as it was'nt set   Optional]
     \* @param partnerCoreUserId    if it sets to '0' its considered as it was'nt set -
     \*                             it gets threads of p2p not groups   Optional]
     \* @param partnerCoreContactId if it sets to '0' its considered as it was'nt set-
     \*                             it gets threads of p2p not groups   Optional]
     \* @param count                Count of the list   Optional]
     \* @param offset               Offset of the list  [Optional]
     \* @param handler               Its not working yet set it to null [Optional]
     \* @param threadIds             List of thread ids that you want to get  [Optional]
     \* @param threadName            Name of the thread that you want to get  [Optional]
     \*/

RequestThread requestThread = new RequestThread.Builder()
.partnerCoreContactId()
.threadIds()
.threadName()
.partnerCoreContactId()
.creatorCoreUserId()
.partnerCoreUserId()
.count()
.offset()
.build();

getThreads(requestThread , null)

```




**۲- getHistory:**

با دریافت آیدی مربوط به یک ترد ، تاریخچه‌ی آن را بر اساس تنظیمات صفحه‌بندی (count,offset) نشان خواهد داد.

```
/**
     \* Gets history of the thread
     \*
     \* @Param count    count of the messages  [Optional]
     \* @Param order    If order is empty [default = desc] and also you have two option [ asc | desc ]       [Optional]
     \* @Param long threadId   Id of the thread 
     \* @Param long fromTime    Start Time of the messages  [Optional]
     \* @Param long fromTimeNanos  Start Time of the messages in Nano second  [Optional]
     \* @Param long toTime         End time of the messages  [Optional]
     \* @Param long toTimeNanos    End time of the messages  [Optional]
     \* @Param @Deprecated long firstMessageId
     \* @Param @Deprecated long lastMessageId
     \*
     \* <p>
     \* threadId Id of the thread that we want to get the history
     \*/

RequestGetHistory requestGetHistory = new RequestGetHistory.Builder(threadId)
                .fromTime()
                .fromTimeNanos()
                .id()
                .toTime()
                .toTimeNanos()
                .build();
chat.getHistory(requestGetHistory , null)

```




**۳- createThread:**

ساخت یک ترد، شامل ساخت ترد نفر به نفر (چت دو نفره) ، یا ترد جمعی (گروه) می‌باشد. در حالت عادی نحوه‌ی ایجاد هر دو مدل یکسان است ، تفاوت در تعداد نفرات گروه نسبت به ترد دو نفره می‌باشد.

```
/*available thread types*/
/*  int NORMAL = 0; 
 \*  int OWNER_GROUP = 1; 
 \*  int PUBLIC_GROUP = 2; 
 \*  int CHANNEL_GROUP = 4; 
 \*  int CHANNEL = 8;
\*/

/*available invitee types*/
/*int TO_BE_USER_SSO_ID = 1; 
 \*int TO_BE_USER_CONTACT_ID = 2; 
 \*int TO_BE_USER_CELLPHONE_NUMBER = 3; 
 \*int TO_BE_USER_USERNAME = 4;
 \*TO_BE_USER_ID = 5  // just for p2p
\*/

Invitee[] invt = new Invitee[]{new Invitee(485, 2)};
chat.createThread(threadType, invt, threadTitle);`...`

```




**۴- muteThread**

با دریافت آیدی ترد، ترد مربوطه را mute می‌کند.

**۵- unmuteThread**

با دریافت آیدی ترد ، مشخصه ی mute ترد مربوطه را در صورت فعال بودن، غیرفعال می‌کند.

نکته: mute و unmute جهت غیرفعال و فعال کردن نوتیفیکیشن یک ترد کاربرد دارد.

```
/**
 	\* Mute the thread so notification is off for that thread
 	\* @param request {
 	\*            	long threadId : id of the thread
 	\* }
 	\* @param handler : its not useful yet. set it to null
 	\*/
   	 RequestMuteThread requestMuteThread = new RequestMuteThread.Builder()
            	.threadId(threadId)
            	.build();
    	chat.muteThread(requestMuteThread);

    	/**
 	\* It Un mutes the thread so notification is off for that thread
 	\*
 	\* @param request {
 	\*            	long threadId : id of the thread
 	\*            	}
 	\* @param handler : its not useful yet. set it to null
 	\*/
     RequestMuteThread muteThread = new RequestMuteThread.Builder()
            	.threadId(threadId)
            	.build();
    	chat.unMuteThread(muteThread,null);

```




**۶- getThreadParticipants:**

با دریافت آیدی ترد و تنظیمات صفحه‌بندی ، اعضای آن ترد را نشان می‌دهد. به عنوان ورودی دوم می‌توان به این متد یک callback اختصاص داد تا پس از پاسخ سرور اجرا شود.

```
	/**
     \* Get the participant list of specific thread
     \* <p>
     \*
     \* @ param long threadId id of the thread we want to get the participant list
     \* @ param long count number of the participant wanted to get
     \* @ param long offset of the participant list
     \*/

RequestThreadParticipant participant = new RequestThreadParticipant.Builder(threadId)
                .count()
                .offset()
                .build();
chat.getThreadParticipants(participant ,null)

```




**۷- addParticipants:**

با دریافت آیدی ترد و لیستی از از آیدی مخاطبین (contact Id) ، آن‌ها را به اعضای ترد مربوطه اضافه می‌کند.

```
/**
 	\* contactIds  List of CONTACT IDs
 	\* threadId   Id of the thread that you are {*NOTICE*}admin of that and you are going to
 	\* add someone as a participant.
 	\*
 	\* @param request {
 	\*            	long threadId : Id of the thread
 	\*            	List<Long> contactIds : list of contact ids that wanted to be add
 	\*            	}
 	\* @param handler : its not useful yet. set it to null
 	\*/
   	  RequestAddParticipants addParticipants = new RequestAddParticipants
            	.Builder(threadId,contactIds)
            	.build();
    	chat.addParticipants(requestAddParticipants, null);

```




**۸- removeParticipants:**

با دریافت آیدی ترد و لیستی از آیدی کاربران (userId)، آن‌ها را از ترد مورد نظر حذف می‌کند.

```
 /**
     \* @param request {
     \*                participantIds :  List of PARTICIPANT IDs from Thread's Participants object
     \*                threadId      : Id of the thread that we wants to remove their participant
     \*                }
     \* @param handler it should be null
     \*/
RequestRemoveParticipants removeParticipants = new RequestRemoveParticipants
                .Builder(threadId,participantsId)
                .build();

        chat.removeParticipants(requestRemoveParticipants, handler);

```




**۹- leaveThread:**

با دریافت آیدی ترد، کاربر را از ترد مربوطه خارج می‌کند.

```
/**
     \* leaves the thread
     \*
     \* @param request{ threadId id of the thread
     \*                 }
     \* @param handler it should be null
     \*/
RequestLeaveThread leaveThread = new RequestLeaveThread.Builder(threadId)
                .build();
        chat.leaveThread(leaveThread,null);

```




**  10- "createThreadWithMessage"**

ساخت یک ترد، شامل ساخت ترد نفر به نفر (چت دو نفره)، یا ترد جمعی (گروه) می‌باشد. در حالت عادی نحوه‌ی ایجاد هر دو مدل یکسان است، تفاوت در تعداد نفرات گروه نسبت به ترد دو نفره می‌باشد.

```
{
  'hasError:' false,
  'errorMessage:' '',
  'errorCode:' 0,
  'result:' {
    'thread:' {
      'id:' 82,
      'joinDate:' undefined,
      'title:' undefined,
      'inviter:' undefined,
      'participants:' undefined,
      'time:' undefined,
      'lastMessage:' undefined,
      'lastParticipantName:' undefined,
      'group:' undefined,
      'partner:' undefined,
      'image:' undefined,
      'unreadCount:' undefined,
      'lastMessageId:' undefined,
      'lastMessageVO:' undefined,
      'partnerLastMessageId:' undefined,
      'partnerLastDeliveredMessageId:' undefined,
      'type:' undefined,
      'metadata': undefined,
      'mute:' undefined,
      'participantCount:' undefined,
      'canEditInfo:' undefined
    }
  }
}

```




**11 - "updateThreadInfo"**

با در یافت اطلاعات ترد آن را اپدیت می‌کند، البته باید در نظر داشت که اطلاعاتی هم که لازم به اپدیت نیست فرستاده شود در غیر اینصورت آن فیلدها خالی اپدیت می‌شوند.

```
    /**
 	\* It updates the information of the thread
 	\* @param request {
 	\*            	String image : image of the thread
 	\*            	long threadId : Id of the thread
 	\*            	String name : Name of the thread
 	\*            	String description : Description of the thread
 	\*            	String metadata : Metadata of the thread
 	\*            	}
 	\* @param handler Its not useful yet.
 	\*          	 
 	\*/
     RequestThreadInfo threadInfo = new RequestThreadInfo.Builder()
            	.threadId()
            	.description()
            	.image()
            	.metadat()
            	.name()
            	.build();
    	chat.updateThreadInfo(request, null);

```


<div class="box-end">
</div>

## مدیریت پیام ها

**۱- sendTextMessage:**

ارسال پیام به یک ترد، با دریافت آیدی ترد و پیغام ارسالی. پس از ارسال پیغام، سه رویداد قابل رخداد است:

1. "onSent": که رویداد پس از ارسال پیغام است و توسط سرور به فرستنده اعلام می‌شود.
2. "onDeliver": پس از تحویل پیغام به گیرنده، سرور به صورت خودکار وضعیت دریافت شدن پیغام توسط گیرنده را به وسیله رویداد onDeliver اعلام می‌کند.
3. "onSeen": اعلام وضعیت پیام دیده شده باید توسط دریافت کننده‌ی پیام ، از طریق فراخوانی متد seen توسط دریافت‌کننده صورت گیرد.سرور پیام رسان به محض دریافت این اطلاعیه ، آن را از طریق رویداد onSeen به اطلاع فرستنده می‌رساند.

```
textMessage = "your text message."; //Required
threadId = 83; //Required

/**
     \* Its sent message but it gets Object as an attribute
     \*
     \* @param requestMessage {
     \*                       String textMessage : text of the message
     \*                       int messageType : type of the message
     \*                       String jsonMetaData : metadata of the message
     \*                       long threadId : The id of a thread that its wanted to send
     \*                       }
     \* @param handler        @param handler Its not useful yet.set it to null
     \*/	
RequestMessage message = new RequestMessage
                .Builder(textMessage,threadId)
                .build();
chat.sendTextMessage(requestMessage, null);

```




**۲- editMessage:**

با دریافت آیدی پیغام و متن جدید پیغام ، پیغام مربوطه را تغییر می‌دهد.

نکته: سرور نتیجه‌ی تغییر پیغام را بر روی رویداد "_onEditedMessage_" گزارش خواهد داد.

```
messageId = 514; //Required
messageContent = "edited message"; //Required

/**
 	\* Message can be edit when you pass the message id and the edited
 	\* content in order to edit your Message.
 	\*
 	\* @param request {
 	\*            	String messageContent : content of them message
 	\*            	long messageId : id of the message it wanted to be edit
 	\*            	String metaData : metaData of the message
 	\*            	}
 	\* @param handler : its not useful yet. set it to null  
 	\*/
   	 equestEditMessage editMessage = new RequestEditMessage.
            	Builder(messageContent,messageId)
            	.metaData()
            	.build();
    	chat.editMessage(editMessage,null);

```




**۳- replyMessage:**

با دریافت آیدی ترد ، آیدی پیام ، و محتوای دلخواه ، پیام مورد نظر شما را انتخاب و محتوا را در پاسخ به آن پیام ارسال می‌کند.

با توجه به این‌که جنس این متد همانند sendTextMessage از نوع ارسال پیام است، در نتیجه سه callback جهت عملیات پس از ارسال، دریافت، و دیده شدن پیام لازم خواهد داشت.

```
threadId = threadId; //Required
repliedTo = messageId; //Required
content = message; //Required

	  /**
 	\* Reply the message in the current thread and send az message and receive at the
 	\* <p>
 	\*
 	\* @param request{ messageContent content of the reply message
 	\*             	threadId   	id of the thread
 	\*             	messageId  	message id of the message that we want to reply
 	\*             	metaData   	meta data of the message
 	\*             	}
 	\* @param handler : its not useful yet. set it to null
 	\*/
   		      	RequestReplyMessage requestReplyMessage = new RequestReplyMessage
            	.Builder(messageContect,threadId,messageId)
            	.messageType()
            	.systemMetaData()
            	.build();
    	chat.replyMessage(request, handler);

```




**۴- forwardMessage:**

این متد ، باز ارسال یک پیام انتخابی را به یک ترد مشخص، با استفاده از آیدی پیام (جهت انتخاب آن) و آیدی ترد مقصد انجام خواهد داد. نوع این متد نیز ارسال پیام است.

```
/* Required fields */
/*  threadId 
 \*  messageIds
\*/

 /**
 	\* forward message to some thread
 	\*
 	\* @param request {
 	\*            	threadId : destination thread id
 	\*            	messageIds : List of message ids that we want to forward them
 	\*            	}
 	\*/
   	 RequestForwardMessage requestForwardMessage = new RequestForwardMessage
            	.Builder(threadId,messageIds)
            	.build();
    	chat.forwardMessage(request);

```




نکته: متد باز ارسال لیستی از پیام‌ها را با دریافت آیدی پیام‌ها به ترد مقصد ارسال می‌کند. در این حالت برای هر پیام یک uniqueId جداگانه خواهد بود.

**۵- sendFileMessage:**

ارسال پیام با محتوای فایل به یک ترد مشخص. با دریافت آیدی ترد مقصد، آدرس فایل مورد نظر، محتوای متن همراه عکس و محتوای مورد نظر متادیتا، فایل ارسالی را پس از آپلود بر روی سرور، به همراه پیام ارسالی به ترد مقصد ارسال می‌کند.

```
/* Required fields */
 \*  threadId
 \*  fileUri
\*/

/**
 	\* This method first check the type of the file and then choose the right
 	\* server and send that
 	\* <p>
 	\*
 	\* @param requestFileMessage {description	Its the description that you want to send with file in the thread
 	\*                        	fileUri    	Uri of the file that you want to send to thread
 	\*                        	threadId   	Id of the thread that you want to send file
 	\*                        	systemMetaData [optional]}
 	\* @param handler        	handler    	it is for send file message with progress
 	\*/
     RequestFileMessage fileMessage = new RequestFileMessage.
            	Builder(activity,threadId,fileUri)
            	.messageType()
            	.systemMetadata()
            	.build();

```




​    

```
    	chat.sendFileMessage(requestFileMessage, handler);

```




**۶- deleteMessage:**

با دریافت آیدی پیام (messageId) ، پیام مربوطه را حذف خواهد کرد.

نکته: در صورتی که متغیر deleteForAll را با مقدار true پر کنید ، پیام مذکور از تاریخچه‌ی ترد همه ی اعضای آن ترد پاک خواهد شد.

```
/* Required fields */
/*  messageId 
\*/

/**
 	\*
 	\* @param request {
 	\*             	ArrayList<Long> messageIds;
 	\*             	boolean deleteForAll : If you want to delete message for everyone you can set it true if u don't want
 	\* you can set it false 
 	\*            	}
 	\* @param handler : its not useful yet. set it to null
 	\*/
   	  RequestDeleteMessage requestDeleteMessage = new RequestDeleteMessage.Builder()
            	.messageIds()
            	.deleteForAll()
            	.build();
    	chat.deleteMessage(deleteMessage, handler);

```




 **7 -"replyFileMessage"**:

پاسخ پیام با محتوای فایل به یک ترد مشخص. با دریافت آیدی ترد مقصد، آدرس فایل مورد نظر، محتوای متن همراه عکس و محتوای مورد نظر متادیتا، فایل ارسالی را پس از آپلود بر روی سرور، به همراه پیام ارسالی به ترد ارسال می‌کند.

```
/**
 	\* Reply the message in the current thread and send az message and receive at the
 	\* <p>
 	\* messageContent content of the reply message
 	\* threadId   	id of the thread
 	\* messageId  	of the message that we want to reply
 	\* metaData   	meta data of the message
 	\*
 	\* @param request {
 	\*            	String messageContent : content of the reply message
 	\*            	long threadId : id of the thread
 	\*            	long messageId : message id of the message that wanted to be reply
 	\*            	String systemMetaData : meta data of the message
 	\*            	Uri fileUri : Uri of the file
 	\*            	Activity activity
 	\*            	int messageType : Type of the message
 	\*            	}
 	\* @param handler
 	\*/
     RequestReplyFileMessage replyFileMessage = new RequestReplyFileMessage
    	.Builder(messageContent,threadId,messageId,fileUri,activity)
    	.messageType()
    	.systemMetaData()
    	.build();
         	chat.replyFileMessage(request, handler);

```




 **8 -"getMessageSeenList"**:

گرفتن لیست کسانی که مسیج را دیده‌اند.

```
  /**
 	\* Gets the list of the participant that the message is seen
 	\*
 	\* @param requestParams {
 	\*                  	long messageId : Id of the message
 	\*                  	}
 	\*/
   	  RequestSeenMessageList seenMessageList = new RequestSeenMessageList
            	.Builder(messageId)
            	.build();
    	chat.getMessageSeenList(seenMessageList);

```




 **9-"getMessageDeliveredList"**:

گرفتن لیست کسانی که مسیج به آن‌ها رسیده است.

```
/**
 	\* Gets the list of the person that the message has been delivered to them
 	\*
 	\* @param requestParams {
 	\*                  	long messageId : Id of the message
 	\*                  	}
 	\*/    
   	  RequestDeliveredMessageList requestDeliveredMessageList = new RequestDeliveredMessageList
            	.Builder(messageId)
            	.build();
    	chat.getMessageDeliveredList(requestDeliveredMessageList);

```




 **10-"resendMessage"**:

فرستادن مسیجی که درصف مانده است.

```
/**
 	\* If you want to resend the message that is stored in waitQueue
 	\*
 	\* @param uniqueId the unique id of the waitQueue message
 	\*/
   	 chat.resendMessage(uniqueId);

```




 **11 -"cancelMessage"**:

کنسل کردن مسیج که در صف مانده است.

```
 /**
 	\* It cancels message if its still in the Queue
 	\*/
	chat.cancelMessage(uniqueId);

```


<div class="box-end">
</div>

## مدیریت فایل‌ها

**۱- uploadImage:** 

با دریافت آدرس فایل عکس، آن را بر روی سرور فایل ذخیره می‌کند.

نکته:پارامترهای context و activity جهت دسترسی به ریسورس‌های دستگاه و بررسی دسترسی‌های موجود لازم است.

```
chat.uploadImage(Context context, Activity activity, Uri fileUri);

RequestUploadImage requestUploadImage = new RequestUploadImage.Builder(activity,fileUri)
                .build();

chat.uploadImage(requestUploadImage);

```




**۲- getImage:**

با دریافت آیدی تصویر ذخیره شده و کد مشخصه‌ی آن (hashCode) لینک دریافت آن را در اختیار قرار می‌دهد.

```
 chat.getImage(imageId ,hashCode);

        RequestGetImage requestGetImage = new RequestGetImage
                .Builder(imageId,hashCode,downloadable)
                .build();
        chat.getImage(requestGetImage);

```




**۳- uploadFile:**

با دریافت آدرس فایل آن را در سرور فایل بارگذاری خواهد کرد.

```
/**
     \* @param requestUploadFile {
     \*                          Activity activity
     \*                          Uri fileUri : Uri of the file
     \*                          }
     \*/		
RequestUploadFile uploadFile = new RequestUploadFile.Builder(activity, uri)
                .build();
        chat.uploadFile(uploadFile);

```




**۴- getFile:**

با دریافت آیدی فایل ذخیره شده و کد مشخصه ی آن (hashCode) لینک آن را در اختیار قرار می‌دهد.این متد پارامتری به عنوان downloadable دارد که از نوع boolean است. در صورت مثبت بودن لینک فایل خروجی قابل دانلود خواهد بود.

```
RequestGetFile requestGetFile = new RequestGetFile
                .Builder(fileId,hashCode,downloadable)
                .build();
        chat.getFile(requestGetFile);

```




**"uploadImageProgress"**:

با استفاده از این متد می‌توانید مقدار بایتی را که در حال آپلود شدن است را با استفاده از اینترفیس ProgressHandler.onProgress دنبال کنید.  

```
	 /**
     \* @param requestUploadImage {
     \*                           Activity activity
     \*                           Uri fileUri : Uri of the file
     \*                           }
     \* @param handler            It has 3 listener{
     \*                           onProgressUpdate(String uniqueId, int bytesSent, int totalBytesSent, int totalBytesToSend)
     \*                           onError(String jsonError, ErrorOutPut error)
     \*                           onFinish(String imageJson, ChatResponse<ResultImageFile> chatResponse)
     \*                           }
     \*/
RequestUploadImage requestUploadImage = new RequestUploadImage.Builder(activity,fileUri)
                .build();
        chat.uploadImageProgress(requestUploadImage, new ProgressHandler.onProgress() {
            @Override
            public void onProgressUpdate(String uniqueId, int bytesSent, int totalBytesSent, int totalBytesToSend) {

            }

            @Override
            public void onFinish(String imageJson, ChatResponse<ResultImageFile> chatResponse) {

            }

            @Override
            public void onError(String jsonError, ErrorOutPut error) {

            }
        });

```




**"uploadFileProgress"**:

با استفاده از این متد می‌توانید مقدار بایتی را که در حال آپلود شدن است را با استفاده از اینترفیس ProgressHandler.onProgress دنبال کنید.

```
/**
     \* It uploads file and it shows progress of the file downloading
     \*
     \* @param requestUploadFile {
     \*                          Activity activity
     \*                          Uri fileUri
     \*                          }
     \* @param handler           {
     \*                          onProgress
     \*                          onFinish
     \*                          onError
     \*                          }
     \*/
	  RequestUploadFile uploadFile = new RequestUploadFile.Builder(activity, uri)
                .build();

        chat.uploadFileProgress(uploadFile, new ProgressHandler.onProgressFile() {
            @Override
            public void onFinish(String imageJson, FileUpload fileImageUpload) {

            }

            @Override
            public void onError(String jsonError, ErrorOutPut error) {

            }

            @Override
            public void onProgress(String uniqueId, int bytesSent, int totalBytesSent, int totalBytesToSend) {

            }

        });

```


<div class="box-end">
</div>

## مدیریت پروفایل

**۱- getUserInfo:**

این متد اطلاعات پروفایل کاربر را در اختیارش قرار می‌دهد. با توجه به توکن دسترسی عمل می‌کند، لذا نیازی به ورودی ندارد.

```
chat.getUserInfo(null);

```




```
//output:

{
  "hasError": false,
  "errorMessage": null,
  "errorCode": 0,
  "result": {
    "user": {
      "id": 41,
      "name": "محمد واحدی",
      "email": null,
      "cellphoneNumber": "0937******6",
      "image": "http://all-dev-fbp-frp-fnp.fns:8080/nzh/image/?imageId=1310&width=178&height=178&hashCode=162d76c669f-0.4826280911609194",
      "lastSeen": null,
      "sendEnable": true,
      "receiveEnable": true
    }
  }
}

```


<div class="box-end">
</div>

## موقعیت و مسیریابی

**۱- mapSearch:**

نام خیابان، اماکن و کسب و کار های ثبت شده و ... (searchTerm) را حول نقطه‌ی مرجع (مختصات طول و عرض جغرافیایی مرجع با متغیرهای latitude , longitude مشخص می‌شود) جستجو می‌کند.

```
chat.mapSearch(String searchTerm, Double latitude, Double longitude);

```




```
{
  "errorCode": 0,
  "errorMessage": null,
  "result": {
    "maps": [
      {
        "region": "تهران",
        "title": "میدان آزادی",
        "category": "place",
        "type": "roundabout",
        "location": {
          "z": "NaN",
          "y": 35.69972390081852,
          "x": 51.33750630393097
        },
        "address": "میدان آزادی - تهران",
        "neighbourhood": "آپادانا"
      },
      .
      .
      .
      {
        "region": "تهران",
        "title": "ایستگاه مترو میدان آزادی",
        "category": "place",
        "type": "subway_station",
        "location": {
          "z": "NaN",
          "y": 35.701164,
          "x": 51.3332562
        },
        "address": "آپادانا، بزرگراه لشگری - تهران",
        "neighbourhood": "آپادانا"
      }
    ]
  },
  "count": 29,
  "hasError": false
}

```




**۲- mapRouting:**

با دریافت دو مختصات مبدا و مقصد بهترین مسیر بین دو نقطه‌ی مشخص را با توجه به ترافیک معابر محاسبه می‌کند و هر پاسخ ممکن است شامل یک یا چند مسیر باشد. در هر مسیر زمان سفر و مسافت آن محاسبه می‌گردد. مرتب‌سازی مسیرها بر اساس بهترین مسیر از نظر زمان و مسافت خواهد بود.

اولین پارامتر ورودی مختصات نقطه شروع مسیریابی، یا همان مبدا است (origin)، این مختصات باید به صورت latitude,longitude باشد که دو عدد با کاما از هم جدا شده‌اند. دومین پارامتر ورودی مقصد است (destination) که مختصات نقطه پایان مسیریابی و قالب آن مانند نقطه شروع است.

```
chat.mapRouting(String origin, String destination);

```




```
{
  "errorCode": 0,
  "errorMessage": null,
  "result": {
    "routes": [
      {
        "legs": [
          {
            "summary": "بزرگراه شهریار - بویین زهرا - ",
            "duration": {
              "value": 5941,
              "text": "۱ ساعت ۳۹ دقیقه"
            },
            "distance": {
              "value": 101358,
              "text": "۱۲۵ کیلومتر"
            },
            "steps": [
              {
                "instruction": "در جهت غرب در میدان آزادی قرار بگیرید",
                "distance": {
                  "value": 238,
                  "text": "۲۵۰ متر"
                },
                "start_location": [
                  51.337639,
                  35.70078
                ],
                "name": "میدان آزادی"
              },
              {
                "instruction": "به مسیر خود ادامه دهید",
                "distance": {
                  "value": 76,
                  "text": "۱۰۰ متر"
                },
                "start_location": [
                  51.335338,
                  35.70004
                ],
                "name": ""
              },
              .
              .
              .
              {
                "instruction": "در مقصد قرار دارید",
                "distance": {
                  "value": 0,
                  "text": "۰ متر"
                },
                "start_location": [
                  50.327996,
                  35.734918
                ],
                "name": ""
              }
            ]
          }
        ],
        "overviewPolyline": ""
      }
    ]
  }
}

```


<div class="box-end">
</div>

## "Event Listeners"

جهت دسترسی به هر یک از این event ها باید به این صورت عمل کنید:

```
chat.addListener(new ChatAdapter() {
            @Override
            public void onSeen(String content) throws IOException {
                super.onSeen(content);
            }
        });

```




یا کلاس خود را از ChatAdapter ارث‌بری کنید:

```
public class MyActivity extends ChatAdapter {
.
.
.
    @Override
    public void onSeen(String content) throws IOException {
        Log.d("RAW_MESSAGE", content);
        super.onSeen(content);
        .
        .
        .
     }
.
.
}

```


<div class="box-end">
</div>

## آدرس‌ها و تنظیمات

تنظیمات و آدرس‌های زیر برای اتصال Async (به روی سرور سندباکس) باید به عنوان پارامتر ورودی پس از ساخت نمونه‌ی اولیه از پکیج، به متد connect داده شود تا اتصال با سرور انجام گیرد.

```
 socketServerAddress = "wss://chat-sandbox.pod.land/ws", // {*REQUIRED*} Socket Server Address
  ssoHost = "https://accounts.pod.land", // {*REQUIRED*} SSO Server Address
  platformHost = "https://sandbox.pod.land:8043/srv/basic-platform", // {*REQUIRED*} Platform Server Address
  fileServer = "http://sandbox.fanapium.com:8080", // {*REQUIRED*} File Server Address
  serverName = "chat-server", // {*REQUIRED*} Server to register on
  token = "CLIENT_ACCESS_TOKEN", // {*REQUIRED*} SSO Token

chat.connect(socketServerAddress, appId, serverName, token , ssoHost, platformHost, fileServer)

```


<div class="box-end">
</div>
