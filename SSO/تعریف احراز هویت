## احراز هویت

سیستم احراز هویت یکپارچه‌ی پاد (POD SSO) این امکان را در اختیار شما قرار می‌دهد که با صرف کمترین زمان و به آسانی و با امنیت بالا، کاربر‌انتان را هویت‌سنجی کرده و برای هر کدام یک حساب کاربری مجزا ایجاد کنید.
سامانه‌ی احراز هویت یکپارچه‌ی پاد عملیات مربوط به حساب کاربری اعضا، مانند ثبت‌نام، تعویض رمز‌ عبور، اجازه‌ی دسترسی برای ورود به سامانه‌های مختلف و تغییر مشخصات را پوشش می‌دهد. این محصول به‌عنوان سامانه‌ی احراز هویت مرکزی مورد استفاده قرار می‌گیرد و خدمات دیگر زیرساخت پایه‌ی کسب‌وکار تحت این سامانه از امنیت کامل برخوردارند. توجه داشته باشید که استفاده از سیستم احراز هویت یکپارچه‌ی پاد یکی از شروط اصلی برای کسب‌وکارهایی است که قصد دارند از سرویس‌های این سرزمین هوشمند استفاده کنند.

<div class="tab-start">
</div> 

# [C#](#tab/csharp)
برای کار با تمامی سرویس هایی پاد باید توکن دسترسی معتبر داشته باشید. همچنین کسب و کارها جهت تعریف کاربران جدید، دریافت و به روزرسانی پروفایل کاربران خود نیز می توانند از سرویس های پاد استفاده کنند که آن نیز مستلزم داشتن توکن معتبر است. تمامی کارهای دریافت و مدیریت توکن توسط این پکیج انجام می شود. این سامانه بر اساس استاندارد OAuth2.0 پیاده سازی شده است و دانستن این استاندارد می تواند کمک بسیاری به شما بکند.

از پکیج SSO می توانید برای ورود به دو روش وب و OTP (رمز یکبار مصرف استفاده کنید). همانطور که از نام آن مشخص است روش وب را در وب سایت ها استفاده می کنیم و از OTP اکثرا برای ورود با تلفن همراه استفاده می شود.

در روش وب، لینک ورود را مطابق با لینک زیر در وب سایت خود قرار دهید. توجه داشته باشید که client_id را می توانید در پنل کسب و کار خود پیدا کنید و آدرس بازگشت (redirect_uri) را نیز باید در این پل ثبت کنید و دقیقا همان آدرس را در این قسمت وارد کنید.

برای اطلاعات بیشتر به لینک http://docs.pod.land/v1.0.8.0/Developer/User/149/SSO مراجعه کنید.

\**طریقه نصب :**

از طریق Package Manager Console و دستورزیر پکیج مربوطه را نصب نمایید.برای دریافت آخرین نسخه پکیج لینک https://www.nuget.org/packages/Pod_SSO چک نمایید.

     Install-Package Pod_SSO -Version 1.0.1

## "OTP"

## فراخوانی متدها

برای فراخونی هریک از متدها, باید یک شی از کلاس SsoService با ورودی شی از ClientInfo ایجاد کنید.

ضروری است ClientId و ClientSecret در کلاس ClientInfo مقداردهی شود.

برای استفاده از هر سرویس باید کلاس ورودی مربوط به آن سرویس مقداردهی کنید و ازبا استفاده از کلاس SsoService و شی ایجاد شده بعنوان ورودی سرویس مورد نظر,سرویس را اجرا کنید.

```csharp
      var clientInfo = new ClientInfo()
    
        {
    
            ClientId = clientId,
    
            ClientSecret = clientSecret
    
        };
    
        var ssoService=new SsoService(ClientInfo);
```

## فراخوانی سرویس Handshake

سرویس handshake به منظور معرفی دستگاه و هم‌چنین تفاهم بر روی پارامترهای امضای دیجیتال(شامل algorithm،keyId) فراخوانی می‌شود.برای فراخوانی این سرویس نیاز به api_token و client_id می‌باشد که از پنل مدیریت کسب و کار قابل دریافت است.هم‌چنین لازم است قبل از فراخوانی، کلید عمومی کسب و کار به سیستم معرفی شده باشد.

برای فراخوانی این سرویس  از تابع Handshake استفاده نمایید و پارامترهای ClientInfo و ApiToken و DeviceUid را مقداردهی نمایید.

+ پارامتر DeviceUid  توسط سرور کسب و کار تولید می‌شود و باید یک شناسه ی منحصر به فرد باشد.

+ پارامتر ClientInfo یک آبجکت از کلاس ClientInfo باید باشد که در این سرویس مقدار ClientInfo.ClientId ضروری است و باید حتما مقداردهی شود.

```csharp
    var output = new HandshakeSrv();
    
    var handshakeVo = HandshakeVo.ConcreteBuilder
    
                        .SetAuthorization({Put your ApitToken})
    
                        .SetDeviceUid({Put your DeviceUid})
    
                        //.SetDeviceLat({Put your DeviceLat})
    
                        //.SetDeviceLon({Put your DeviceLon})
    
                        //.SetDeviceName("{Put your DeviceName}")
    
                        //.SetDeviceOs("{Put your DeviceOs}")
    
                        //.SetDeviceOsVersion("{Put your DeviceOsVersion}")
    
                        //.SetDeviceType(DeviceType.MobilePhone) //{Put your DeviceType}
    
                        .Build();
    
    ssoService.Handshake(handshakeVo, response => Listener.GetResult(response, out output));
```

## درخواست دریافت کد OTP
 پس از صدا زدن این سرویس ، کد (رمز یکبار مصرف) به تلفن و یا ایمیل داده شده  ارسال می گردد. توجه داشته باشید رمز ارسال شده پس از 300 ثانیه منقضی می گردد.

- پارامتر state اختیاری می باشد و در نمونه کد زیر کامنت شده است. در صورت ارسال، در پاسخ سرویس Verify آن را دریافت خواهید کرد.

- برای فراخوانی این سرویس از تابع Authorize استفاده نمایید و پارامترهای identity , keyId ,privateKey  را حتما مقداردهی نمایید. 

-  پارامتر Identity می تواند حاوی شماره تلفن و یا ایمیل کاربر باشد.

- مقدار پارامتر  ResponseType  باید حتما "code" باشد.

```csharp
    var output = new SentVerificationDTOSrv();
    
    var authorizeVo = AuthorizeVo.ConcreteBuilder
    
                        .SetIdentity(identity)
    
                        .SetAuthorization(keyId, privateKey)
    
                        .SetResponseType("code")
    
                        //.SetCallbackUri("{Put your CallbackUri}")
    
                        //.SetClientId("{Put your ClientId}")
    
                        //.SetCodeChallenge("{Put your CodeChallenge}")
    
                        //.SetCodeChallengeMethod("{Put your CodeChallengeMethod}")
    
                        //.SetIdentityType("{Put your IdentityType}")
    
                        //.SetLoginAsUserId("{Put your LoginAsUserId}")
    
                        //.SetRedirectUri("{Put your RedirectUri}")
    
                        //.SetReferrer("{Put your Referrer}")
    
                        //.SetReferrerType({Put your ReferrerType})
    
                        //.SetResponseType("{Put your ResponseType}")
    
                        .Build();
    
    ssoService.Authorize(authorizeVo, response => Listener.GetResult(response, out output));
```

## تایید OTP
تایید otp به به صورت کد زیر است که در صورت ورود کد تایید درست و یا نادرست پیغام ورود موفق و ناموفق روی identity ارسالی دریافت خواهید نمود.

- پارامتر Identity می تواند حاوی شماره تلفن و یا ایمیل کاربر باشد.

```csharp

    var output = new OAuthResponseSrv();
    
    var verifyVo = VerifyVo.ConcreteBuilder
    
                        .SetIdentity({Put your Identity})
    
                        .SetAuthorization({Put your KeyId}, {Put your PrivateKey})
    
                        .SetOtp({Put your Otp})
    
                        .Build();
    
    ssoService.Verify(verifyVo, response => Listener.GetResult(response, out output));
```

## دریافت توکن دسترسی کاربر
برای دریافت توکن دسترسی از تابع  GetAccessTokenByOtp  استفاده نمایید.مقدار پارامتر GrantType  باید حتما "authorization_code"  باشد.

پاسخ سرویس حاوی refresh_token، access_token و id_token می باشد که اعتبار access_token به مدت 15 دقیقه می باشد.

"Id_token" یک توکن self_encoded می باشد که فقط جهت شناسایی کاربر در مواقعی که بین چندین دستگاه جابجا می‌شود، استفاده می‌شود و برای دسترسی به api سرویس ها غیرقابل استفاده می باشد.

"access_token " را به اپلیکیشن ارسال نمایید و توجه نمایید که refresh_token را سمت سرور نگه داری کرده و به اپلیکیشن ارسال ننمایید. ازrefresh_token  برای دریافت توکن جدید استفاده نمایید.

```csharp
    var output = new OAuthResponseSrv();
    
    var accessTokenByOtpVo = AccessTokenByOtpVo.ConcreteBuilder
    
                        .SetCode({Put your Code})
    
                        .SetGrantType("authorization_code")
    
                        .Build();
    
    ssoService.GetAccessTokenByOtp(accessTokenByOtpVo, response => Listener.GetResult(response, out output));
```
# SSO

## دریافت توکن دسترسی کاربر
برای دریافت توکن دسترسی از تابع  GetAccessToken استفاده نمایید.مقدار پارامتر  GrantType  باید حتما "authorization_code"  باشد.

مقدار RedirectUri  باید دقیقا مطابق با Uri ای که در پنل کسب و کار خورد تعریف کرده ای برابر باشد.

```csharp
    var output = new OAuthResponseSrv();
    
    var accessTokenVo = AccessTokenVo.ConcreteBuilder
    
                        .SetCode({Put your Code})
    
                        .SetGrantType("authorization_code")
    
                        .SetRedirectUri({Put your RedirectUri})
    
                        .Build();
    
    ssoService.GetAccessToken(accessTokenVo, response => Listener.GetResult(response, out output));
```

## به روز رسانی توکن دسترسی کاربر
از آنجایی که توکن کاربر هر 900 ثانیه منقضی میشود باید این توکن را با استفاده از refresh_token  بروزرسانی کرد و access_token جدید دریافت کرد.

برای این کار از تابع RefreshAccessToken استفاده می کنیم و کلاس RefreshTokenVo  را مقداردهی می کنیم.

```csharp
    var output = new OAuthResponseSrv();
    
    var refreshTokenVo = RefreshAccessTokenVo.ConcreteBuilder
    
                        .SetGrantType("refresh_token")
    
                        .SetRefreshToken({Put your RefreshToken})
    
                        .Build();
    
    ssoService.RefreshAccessToken(refreshTokenVo, response => Listener.GetResult(response, out output));
```

## دریافت اطلاعات توکن
می توان اطلاعات توکن را از جمله فعال یا غیرفعال بودن آن , از طریق تابع GetTokenInfo و  مقداردهی کلاس TokenInfoVo , دریافت کرد.

فقط ضروری است پارامتر  TokenTypeHint با توجه به توکن مربوطه یکی از دو مقدار زیر باشد:

"TokenType.access_token"

,or

"TokenType.refresh_token"

,or

"TokenType.id_token"

```csharp
       var output = new TokenInfoSrv();
    
        var tokenInfoVo = TokenInfoVo.ConcreteBuilder
    
                            .SetToken({Put your Token})
    
                            .SetTokenTypeHint({Put your TokenTypeHint})
    
                            .Build();
    
        ssoService.GetTokenInfo(tokenInfoVo, response => Listener.GetResult(response, out output));
```

## ابطال  توکن

می توان توکن را از طریق تابع RevokeToken و مقداردهی کلاس RevokeTokenVo  ابطال کرد.

فقط ضروری است پارامتر  TokenTypeHint با توجه به توکن مربوطه یکی از دو مقدار زیر باشد:

"RevokeTokenType.access_token"

,or

"RevokeTokenType.refresh_token"

```csharp
       var output = string.Empty;
    
        var revokeTokenVo = RevokeTokenVo.ConcreteBuilder
    
                            .SetTokenTypeHint({Put your TokenTypeHint})
    
                            .SetToken({Put your Token})
    
                            .Build();
    
        ssoService.RevokeToken(revokeTokenVo, response => Listener.GetResult(response, out output));
```

# [PHP](#tab/php)

## SSO

## نصب پکیج pod-sso-service

پکیج ارائه شده برای  سامانه ورود یکپارچه، pod-sso-service، از طریق دستور زیر قابل نصب می باشد.

    composer require pod-sdk/pod-sso-service

این پکیج شامل تمام api های لازم برای احرازهویت از طریق وب و از طریق دستگاه (با استفاده از رمز یکبار مصرف) می باشد 

متدهای ارائه شده  شامل موارد زیر می باشند : 

وب : 

1.  "getAccessToken"
2. " refreshAccessToken"
3.  "getTokenInfo"
4.  "revokeToken"

"OTP":  

1. " handshake"
2.  "SignatureAuthorize"
3. " getOtpScenario"
4.  "verifyOTP"
5.  "getAccessTokenByOtp"
6.  "getAccessTokenByOtpScenario"

در ادامه نمونه کدهایی برای استفاده از هر کدام از متدهای ذکر شده ارائه شده است.

این سامانه بر اساس استاندارد OAuth2.0 پیاده سازی شده است، بنابراین جهت استفاده از سرویس های پلتفرم بایستی بر اساس این استاندارد جهت ورود کاربران و دریافت توکن استفاده کنیم. روش کلی به این صورت است که برای ورود کاربر، وی را به صفحه ورود سرور SSO راهنمایی میکنیم و پس از ورود کاربر، کد مربوط به کاربر به آدرس تعریف شده توسط کسب و کار ارسال می گردد. سپس با ارسال کد دریافت شده به سرور sso توکن دسترسی کاربر در یافت می شود پس از دریافت توکن، میتوان از آن برای صدازدن سایر سرویس های پلتفرم استفاده نمود و یا اطلاعات پروفایل کاربر را دریافت و ویرایش نمود. 

راهنمای چگونگی دریافت کد در لینک زیر آورده شده است.

توجه : این کد در مدت کوتاهی منقضی میشود. بنابرین بلافاصله باید نسبت به دریافت access_token و refresh_token اقدام شود.

**راهنمای دریافت کد**
ار آنجایی که در تمام متدهای احراز هویت نیاز به ارسال اطلاعات client_id و client_secret می باشد از کلاس ClientInfo برای تنظیم این مقادیر استفاده شده است که به عنوان پارامتر ورودی به کلاس SSOService ارسال می شود. 

در زیر نمونه کد برای این تنظیمات آورده شده است:

```php
      # required classes
        use Pod\Base\Service\Exception\PodException;
        use Pod\Base\Service\Exception\ValidationException;
        use Pod\Sso\Service\SSOService;
        use Pod\Base\Service\ClientInfo;
        
        const CLIENT_ID = 'YOUR_CLIENT_ID';
        const CLIENT_SECRET = 'YOUR_CLIENT_SECRET';
        const REDIRECT_URI = 'YOUR_REDIRECT_URI';
        const API_TOKEN = 'YOUR_API_TOKEN';
        
        $clientInfo = new ClientInfo();
        $clientInfo->setClientId(CLIENT_ID);
        $clientInfo->setClientSecret(CLIENT_SECRET);
        
        // for get Access Token and Refresh Access Token you need set redirect uri
        $clientInfo->setRedirectUri(REDIRECT_URI);
        
        #  instantiates a SSOService
        $SSOService = new SSOService($clientInfo);
```

## دریافت توکن دسترسی کاربر
پس از دریافت کد برای دریافت توکن دسترسی کاربربا استفاده از نمونه کد زیر و با پر کردن پارامترهای ورودی می توانید توکن دسترسی کاربر را دریافت نمایید.

```php
       $params = [
          "code" => "put code here" # use code that you receive in url
       ];
    
       try {
            $result = $SSOService->getAccessToken($params);
            print_r($result);
        } catch (ValidationException $e) {
            print_r($e->getResult());
            print_r($e->getErrorsAsArray());
        } catch (PodException $e) {
            print_r($e->getResult());
        }
```

## بروزرسانی توکن دسترسی کاربر
پس از گذشت زمان expires_in ، توکن دسترسی کاربر منقضی می شود. با استفاده از refresh_token و تابع زیر، توکن معتبر جدید درخواست دهید.

```php
     $params = [
            "refresh_token" => "put refresh token"
        ];
    
        try {
            $result = $SSOService->refreshAccessToken($params);
            print_r($result);
        } catch (ValidationException $e) {
            print_r($e->getResult());
            print_r($e->getErrorsAsArray());
        } catch (PodException $e) {
            print_r($e->getResult());
        }
```

## ابطال توکن
ممکن است به هر دلیلی بخواهید دسترسی برنامه به اطلاعات حساب کاربر را از بین ببرید. برای این کار می توانید از ابطال توکن استفاده کنید.

```php
    # set token and token_type_hint
        $params = [
            "token" => API_TOKEN,
            "token_type_hint" => "put token type to `refresh_token` or `access_token`",
        ];
    
        try {
            $result = $SSOService->revokeToken($params);
            print_r($result);
        } catch (ValidationException $e) {
            print_r($e->getResult());
            print_r($e->getErrorsAsArray());
        } catch (PodException $e) {
            print_r($e->getResult());
        }
```

## دریافت اطلاعات توکن 
برای این که از صحت و اعتبار توکن کاربر خود مطلع شوید می توانید اطلاعات توکن مورد نظر را دریافت کنید.

```php
       # set token and token_type_hint
            $params = [
                "token" => API_TOKEN,
                "token_type_hint" => "put token type to `refresh_token` or `access_token`",
            ];
    
            try {
                $result = $SSOService->getTokenInfo($params);
                print_r($result);
            } catch (ValidationException $e) {
                print_r($e->getResult());
                print_r($e->getErrorsAsArray());
            } catch (PodException $e) {
                print_r($e->getResult());
            }
```

## OTP
## ورود با OTP با سرور
جهت ایجاد امکان ورود با رمز یکبار مصرف (OTP) برای کاربران، در حالتی که کسب و کار دارای سرور امن و قابلیت ایجاد ارتباط با SSO پاد از طریق سرور خود باشد، این روش پیشنهاد می گردد.

لازم است از طریق سرور، به ازای هر شماره موبایل یا دستگاهی که میخواهد لاگین شود، اطلاعات دستگاه را با متد handshake به SSO معرفی نمایید و keyId دریافت کنید.

http://docs.pod.land/v1.0.8.0/Developer/User/1861/otpwithserver

## فراخوانی سرویس Handshake سمت SSO
سرویس handshake به منظور معرفی دستگاه و هم‌چنین تفاهم بر روی پارامترهای امضای دیجیتال(شامل algorithm،keyId) فراخوانی می‌شود.برای فراخوانی این سرویس علاوه بر api_token و client_id که از پنل مدیریت کسب و کار قابل دریافت است، لازم است کلید عمومی کسب و کار به سیستم معرفی شده باشد.

```php
    $params = [
        ## =========================================== *Required Parameters ============================================
        "api_token"             => API_TOKEN,
        "device_uid"            => 'put device unique id here',         # Device unique id ,maximum 255 character
        ## =========================================== *Optional Parameters ============================================
        "device_name"           => 'put device name here',
        "device_type"           => 'put device type here',
        "device_lat"            => 'put device latitude here',
        "device_lon"            => 'put device longitude here',
        "device_os"             => 'put device os here',
        "device_os_version"     => 'put device os version here',
    
    ];
    try {
        $result = $SSOService->handshake($params);
        print_r($result);
    } catch (ValidationException $e) {
        print_r($e->getResult());
        print_r($e->getErrorsAsArray());
    } catch (PodException $e) {
        print_r($e->getResult());
    }
```

## درخواست دریافت کد OTP
 پس از دریافت  key_id از مرحله قبل و با استفاده از کلید خصوصی (private_key)  از متد زیر برای ساخت امضای دیجیتال و ارسال آن و همچنین دریافت کد OTP اقدام کنید. کد مورد نظر بر اساس مقدار فیلد identity  که می فرستید به کاربر مورد نظر از طریق پیامک یا ایمیل فرستاده می شود.

```php
      $privateKey = file_get_contents('put your private key file name');
        $params = [
            ## =========================================== *Required Parameters ============================================
            "privateKey"                => $privateKey,
            "keyId"                     => 'put key id that you receive from handshake here',
    //          "algorithm"                 => OPENSSL_ALGO_SHA256,
            "identity"                  => 'put identity [mobile phone number or email address] here',
            "response_type"             => 'code', # code | token | id_token
            ## =========================================== *Optional Parameters ============================================
            "identityType"              => 'put PHONE  identity type [PHONE | EMAIL]',
            "loginAsUserId"             => 'put loginAsUserId',
            "state"                     => 'put state',
            "client_id"                 => 'put client_id',
            "redirect_uri"              => 'put redirect_uri',
            "callback_uri"              => 'put callback_uri',
            "scope"                     => 'put scope',
            "code_challenge"            => 'put code_challenge',
            "code_challenge_method"     => 'put code_challenge_method',
            "referrer"                  => 'put referrer',
            "referrerType"              => 'put referrerType',
    
        ];
        try {
            $result = $SSOService->signatureAuthorize($params);
            print_r($result);
        } catch (ValidationException $e) {
            print_r($e->getResult());
            print_r($e->getErrorsAsArray());
        } catch (PodException $e) {
            print_r($e->getResult());
        }
```

## تایید کد OTP
پس از دریافت otp  کاربر باید آن را ارسال کند. از طریق کد زیر و با استفاده امضای دیجیتالی که در متد signatureAuthorize دریافت می کنید  برای تایید کد otp ارسالی از کاربر استفاده کنید :

```php
      $params = [
            ## =========================================== *Required Parameters ============================================
            "keyId"                     => 'put key id that you received from handshake here',
            "signature"                 =>   $signature,
            "otp"                       => 'put otp that is received from user here',
            "identity"                  => 'put identity [phone or email] here',
        ];
    
        try {
            $result = $SSOService->verifyOTP($params);
            print_r($result);
        } catch (ValidationException $e) {
            print_r($e->getResult());
            print_r($e->getErrorsAsArray());
        } catch (PodException $e) {
            print_r($e->getResult());
        }
```

## دریافت توکن از سرور SSO
با استفاده از کد دریافتی از متد verifyOTP و ارسال آن از طریق متد getAccessTokenByOTP توکن دسترسی را از سرور SSO دریافت کنید: 

```php
       $params = [
            "code" => "put code", # use code that you received after verify otp
        ];
    
        try {
            $result = $SSOService->getAccessTokenByOTP($params);
            print_r($result);
        } catch (ValidationException $e) {
            print_r($e->getResult());
            print_r($e->getErrorsAsArray());
        } catch (PodException $e) {
            print_r($e->getResult());
        }
```        

# [Java](#tab/java)
# "OTP"
ابتدا jar فایل مربوطه را دانلود کرده و در پروژه خود قرار دهید.
جهت ایجاد امکان ورود با رمز یکبار مصرف (OTP) برای کاربران، در حالتی که کسب و کار دارای سرور امن و قابلیت ایجاد ارتباط با SSO پاد از طریق سرور خود باشد، این روش پیشنهاد می گردد.

لازم است از طریق سرور، به ازای هر شماره موبایل یا دستگاهی که میخواهد لاگین شود، اطلاعات دستگاه را با متد handshake به SSO معرفی نمایید و keyId دریافت کنید.

## فراخوانی سرویس handshake سمت SSO
سرویس handshake به منظور معرفی دستگاه و هم‌چنین تفاهم بر روی پارامترهای امضای دیجیتال (شامل algorithm،keyId) فراخوانی می‌شود.برای فراخوانی این سرویس نیاز به api_token و client_id می‌باشد که از پنل مدیریت کسب و کار قابل دریافت است.هم‌چنین لازم است قبل از فراخوانی، کلید عمومی کسب و کار به سیستم معرفی شده باشد:

تست و نمونه کد:

```java
       SsoService ssoService = new SsoService();
    
                try {
    
                    HandshakeVo handshakeVo = new HandshakeVo
    
                            .Builder()
    
                            .setAuthorization(API_KEY)
    
                            .setDevice_uid(SAMPLE_UID)
    
                            .setClient_id(CLIENT_ID)
    
                            .build();
    
                    ssoService.handshake(handshakeVo, new OnGetResponseListenerHandshake() {
    
                        @Override
    
                        public void onResponse(HandshakeSrv handshakeSrv) {
    
                            System.out.println("KeyId: " + handshakeSrv.getKeyId());
    
                        }
    
                        @Override
    
                        public void onFailed(PodException e) {
    
                            System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                        }
    
                    });
    
                } catch (PodException e) {
    
                    System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                }
```

پارامتر **device_uid** توسط سرور کسب و کار تولید می‌شود و باید یک شناسه ی منحصر به فرد باشد.

زمان منقضی شدن کلید، یکسال می‌باشد.

در مرحله بعد لازم است با کلید دریافت شده و کلید خصوصی کسب و کار یک امضای دیجیتال تولید شود و همراه شماره موبایل کاربر به **SSO** ارسال گردد. 

## ساخت signature

پس از دریافت **keyId** و **privateKey**، به روش زیر اقدام به ساخت امضای دیجیتال نمایید و مقدار امضای دیجیتال را در پارامتر **Authorization** قرار دهید.

پارامتر **Authorization** متشکل از سه بخش **Signature keyId** و **signature** و **headers** است:

_ **"Signature keyId"**:  مقدار دریافت شده شناسه کلید (**keyId**) از سرویس **handshake**.

_ **"signature"**:  ساخت **sign** به فرمت **base64** (توضیح نحوه ساخت در ادامه).

_ مقدار **headers**  دقیقا برابر با **host**  و یا **host date** می‌باشد.

Authorization=Signature keyId="keyId مقدار",signature="sign مقدار",headers="host"

ساخت **signature** مطابق با استاندارد **IETF: Signing HTTP Messages** و به روش زیر ساخته می‌شود.

اگر مقدار **headers** را برابر با **host** لحاظ نمودید، **host: accounts.pod.land** را به همراه مقدار **privateKey** با الگوریتم **RSA-SHA256** و به فرمت **base64** رمز نگاری نمایید.

و اگر مقدار **headers** را برابر با **host date** لحاظ نمودید، مقدار زیر را به همراه مقدار **privateKey** هش نمایید:

host: accounts.pod.land

date: Sat Jun 09 2018 17:47:37 GMT+0430

سپس رشته به دست آمده را در مقدار **signature** قرار دهید.

برای مشاهده یک مثال از نحوه ساخت **signature**، می‌توانید سایت https://accounts.pod.land/secTools.html را ببینید. همچنین می توانید از کلاس SigUtils که به زبان جاوا نوشته شده است استفاده نمایید.

##  درخواست دریافت کد OTP

پارامتر **identity** می تواند حاوی شماره تلفن و یا ایمیل کاربر باشد.

پس از صدا زدن این سرویس، کد (رمز یکبار مصرف) به تلفن و یا ایمیل داده شده  ارسال می گردد. توجه داشته باشید رمز ارسال شده پس از 300 ثانیه منقضی می گردد.

پارامتر state اختیاری می باشد و در صورت ارسال، در پاسخ سرویس بعدی آن را دریافت خواهید کرد.

در پاسخ این سرویس شماره تلفن و یا ایمیل را در فیلد **identity** و شناسه کاربر را در فیلد **user_id** دریافت خواهید کرد. در صورتیکه کاربر جدید باشد **user_id** مقدار نخواهد داشت و پس از صدا زدن سرویس **verify** کاربر ثبت نام خواهد شد.

```java
      SsoService ssoService = new SsoService();
    
                try {
    
                    AuthorizeVo authorizeVo = new AuthorizeVo
    
                            .Builder()
    
                            .setResponse_type("code")
    
                            .setKeyId(SAMPLE_KEY_ID)
    
                            .setSignature(SAMPLE_SIGNATURE)
    
                            .setHeaders(SAMPLE_HEADER)
    
                            .setIdentity(SAMPLE_IDENTITY)
    
        //                .setReferrer("")
    
        //                .setReferrerType("")
    
        //                .setState("")
    
                            .build();
    
                    ssoService.authorize(authorizeVo, new OnGetResponseListenerAuthorize() {
    
                        @Override
    
                        public void onResponse(AuthorizeSrv authorizeSrv) {
    
                            System.out.println("expire_in: " + authorizeSrv.getExpires_in() + "\n" +
    
                                    "user_id: " + authorizeSrv.getUser_id());
    
                        }
    
                        @Override
    
                        public void onFailed(PodException e) {
    
                            System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                        }
    
                    });
    
                } catch (PodException e) {
    
                    System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                }
```

-توجه داشته باشید در اینجا، مقدار **user_id** برابر با **sso_id** واقعی(سمت core) است.

**خطای رایج در سرویس فوق** 
اگر"identity" ارسال شده در سرویس، در سامانه پاد وریفای شده باشد (و یا به عبارت دیگر، متصل به userId) باشد، باید در مقدار پارامترclient_id ، شناسه مشتری متصل به همان "identity" فراخوانی شود؛ در غیر این صورت خطای Invalid client Id  را دریافت خواهید کرد.

**تایید otp** به شکل زیر است:

```java
       SsoService ssoService = new SsoService();
    
                try {
    
                    VerifyVo verifyVo = new VerifyVo
    
                            .Builder()
    
                            .setIdentity(SAMPLE_IDENTITY)
    
                            .setOtp("")
    
                            .setKeyId(SAMPLE_KEY_ID)
    
                            .setSignature(SAMPLE_SIGNATURE)
    
                            .setHeaders(SAMPLE_HEADER)
    
                            .build();
    
                    ssoService.verify(verifyVo, new OnGetResponseListenerVerify() {
    
                        @Override
    
                        public void onResponse(VerifySrv verifySrv) {
    
                            System.out.println("code: " + verifySrv.getCode());
    
                        }
    
                        @Override
    
                        public void onFailed(PodException e) {
    
                            System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                        }
    
                    });
    
                } catch (PodException e) {
    
                    System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                }
```

در پاسخ سرویس فوق، پارامترهای code و state (در صورت وجود) را دریافت خواهید نمود.

**خطای رایج در سرویس فوق**: 

با ارسال کد اشتباه تا سه مرتبه، device  قفل خواهد شد و تا 15 دقیقه مجوز لاگین نخواهید داشت.

-در صورت ورود کد تایید درست و یا نادرست پیغام ورود موفق و ناموفق روی identity ارسالی دریافت خواهید نمود.

## دریافت توکن از سرور SSO
برای دریافت توکن سرویس زیر را فراخوانی نمایید:

```java
    SsoService ssoService = new SsoService();
    
            ClientInfoVo clientInfoVo = new ClientInfoVo();
    
            clientInfoVo.setClient_id(CLIENT_ID);
    
            clientInfoVo.setClient_secret(CLIENT_SECRET);
    
            try {
    
                GetAccessTokenByOtpVo getAccessTokenByOtpVo = new GetAccessTokenByOtpVo
    
                        .Builder()
    
                        .setClientInfoVo(clientInfoVo)
    
                        .setGrant_type(GRANT_TYPE)
    
                        .setCode("")
    
                        .build();
    
                ssoService.getAccessTokenByOtp(getAccessTokenByOtpVo, new OnGetResponseListenerGetAccessTokenOtp() {
    
                    @Override
    
                    public void onResponse(GetAccessTokenOtpSrv getAccessTokenOtpSrv) {
    
                        System.out.println("Access token: " + getAccessTokenOtpSrv.getAccess_token() + "\n" +
    
                                "Refresh token: " + getAccessTokenOtpSrv.getRefresh_token());
    
                    }
    
                    @Override
    
                    public void onFailed(PodException e) {
    
                        System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                    }
    
                });
    
            } catch (PodException e) {
    
                System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
            }
```

پاسخ سرویس حاوی refresh_token، access_token و id_token می باشد که اعتبار access_token به مدت 15 دقیقه می باشد.

"Id_token" یک توکن self_encoded می باشد که فقط جهت شناسایی کاربر در مواقعی که بین چندین دستگاه جابجا می‌شود، استفاده می‌شود و برای دسترسی به api سرویس ها غیرقابل استفاده می باشد.

-"access_token" را به اپلیکیشن ارسال نمایید و توجه نمایید که refresh_token را سمت سرور نگه داری کرده و به اپلیکیشن ارسال ننمایید. ازrefresh_token  برای دریافت توکن جدید استفاده نمایید.

 
```java
       SsoService ssoService = new SsoService();
    
                ClientInfoVo clientInfoVo = new ClientInfoVo();
    
                clientInfoVo.setClient_id(CLIENT_ID);
    
                clientInfoVo.setClient_secret(CLIENT_SECRET);
    
                try {
    
                    RefreshAccessTokenVo refreshAccessTokenVo = new RefreshAccessTokenVo
    
                            .Builder()
    
                            .setClientInfoVo(clientInfoVo)
    
                            .setGrant_type("refresh_token")
    
                            .setRefresh_token("e5ded84ac41e479996c19932052f9605")
    
                            .build();
    
                    ssoService.refreshAccessToken(refreshAccessTokenVo, new OnGetResponseListenerRefreshAccessToken() {
    
                        @Override
    
                        public void onResponse(RefreshAccessTokenSrv refreshAccessTokenSrv) {
    
                            System.out.println("Access token: " + refreshAccessTokenSrv.getAccess_token() + "\n" +
    
                                    "Refresh token: " + refreshAccessTokenSrv.getRefresh_token());
    
                        }
    
                        @Override
    
                        public void onFailed(PodException e) {
    
                            System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                        }
    
                    });
    
                } catch (PodException e) {
    
                    System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                }
```

برای این قسمت دو سناریو در نظر گرفته شده است. در اولین سناریو ابتدا متد handshake و سپس متد authorize فراخوانی شده است:

 ```java
       SsoService ssoService = new SsoService();
    
                try {
    
                    HandshakeVo handshakeVo = new HandshakeVo
    
                            .Builder()
    
                            .setAuthorization(API_KEY)
    
                            .setDevice_uid(SAMPLE_UID)
    
                            .setClient_id(CLIENT_ID)
    
                            .build();
    
                    ssoService.handshake(handshakeVo, new OnGetResponseListenerHandshake() {
    
                        @Override
    
                        public void onResponse(HandshakeSrv handshakeSrv) throws PodException {
    
                            SsoService ssoService = new SsoService();
    
                            AuthorizeVo authorizeVo = new AuthorizeVo
    
                                    .Builder()
    
                                    .setResponse_type("code")
    
                                    .setKeyId(handshakeSrv.getKeyId())
    
                                    .setSignature(SAMPLE_SIGNATURE)
    
                                    .setHeaders(SAMPLE_HEADER)
    
                                    .setIdentity(SAMPLE_IDENTITY)
    
        //                .setReferrer("")
    
        //                .setReferrerType("")
    
        //                .setState("")
    
                                    .build();
    
                            ssoService.authorize(authorizeVo, new OnGetResponseListenerAuthorize() {
    
                                @Override
    
                                public void onResponse(AuthorizeSrv authorizeSrv) {
    
                                    System.out.println("expire_in: " + authorizeSrv.getExpires_in() + "\n" +
    
                                            "user_id: " + authorizeSrv.getUser_id());
    
                                }
    
                                @Override
    
                                public void onFailed(PodException e) {
    
                                    System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                                }
    
                            });
    
                        }
    
                        @Override
    
                        public void onFailed(PodException e) {
    
                            System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                        }
    
                    });
    
                } catch (PodException e) {
    
                    System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                }
```

در سناریوی دوم ابتدا متد verify و سپس متد getAccessTokenByOtp  فراخوانی شده است:

 ```java
       SsoService ssoService = new SsoService();
    
                try {
    
                    VerifyVo verifyVo = new VerifyVo
    
                            .Builder()
    
                            .setIdentity(SAMPLE_IDENTITY)
    
                            .setOtp(otp)
    
                            .setKeyId(SAMPLE_KEY_ID)
    
                            .setSignature(SAMPLE_SIGNATURE)
    
                            .setHeaders(SAMPLE_HEADER)
    
                            .build();
    
                    ssoService.verify(verifyVo, new OnGetResponseListenerVerify() {
    
                        @Override
    
                        public void onResponse(VerifySrv verifySrv) throws PodException {
    
                            SsoService ssoService = new SsoService();
    
                            ClientInfoVo clientInfoVo = new ClientInfoVo();
    
                            clientInfoVo.setClient_id(CLIENT_ID);
    
                            clientInfoVo.setClient_secret(CLIENT_SECRET);
    
                            GetAccessTokenByOtpVo getAccessTokenByOtpVo = new GetAccessTokenByOtpVo
    
                                    .Builder()
    
                                    .setClientInfoVo(clientInfoVo)
    
                                    .setGrant_type(GRANT_TYPE)
    
                                    .setCode(verifySrv.getCode())
    
                                    .build();
    
                            ssoService.getAccessTokenByOtp(getAccessTokenByOtpVo, new OnGetResponseListenerGetAccessTokenOtp() {
    
                                @Override
    
                                public void onResponse(GetAccessTokenOtpSrv getAccessTokenOtpSrv) {
    
                                    System.out.println("Access token: " + getAccessTokenOtpSrv.getAccess_token() + "\n" +
    
                                            "Refresh token: " + getAccessTokenOtpSrv.getRefresh_token());
    
                                }
    
                                @Override
    
                                public void onFailed(PodException e) {
    
                                    System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                                }
    
                            });
    
                        }
    
                        @Override
    
                        public void onFailed(PodException e) {
    
                            System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                        }
    
                    });
    
                } catch (PodException e) {
    
                    System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                }
```

## "SSO"
این سرور که جزئی از پلتفرم می باشد به عنوان سامانه احراز هویت مرکزی مورد استفاده قرار می گیرد. اکثر سرویس هایی که در ادامه معرفی می شوند باید دارای توکن معتبر از این سرور باشند.

همچنین کسب و کارها جهت تعریف کاربران جدید، دریافت و به روزرسانی پروفایل کاربران خود می توانند از این سرور استفاده نمایند و نیازی به نگهداری اطلاعات کاربران در سیستم خود ندارند.

این سامانه بر اساس استاندارد OAuth2.0  پیاده سازی شده است بنابراین جهت استفاده از سرویس های پلتفرم بایستی بر اساس این استاندارد جهت ورود کاربران و دریافت توکن استفاده نمایند.

روش کلی به این صورت است که برای ورود کاربر، وی را به صفحه ورود سرور SSO راهنمایی میکنیم و پس از ورود کاربر، توکن مربوط به کاربر به آدرس تعریف شده توسط کسب و کار ارسال می گردد. پس از دریافت توکن، میتوان از آن برای صدازدن سایر سرویس های پلتفرم استفاده نمود و یا اطلاعات پروفایل کاربر را دریافت و ویرایش نمود.

## ‌ورود
برای ورود کاربران از طریق **SSO**  پاد از آدرس زیر استفاده کنید. مقدار client_id   خود را در آن قرار دهید و آدرسی که می خواهید پاسخ درخواست را در آن دریافت کنید را به عنوان پارامتر  redirect_uri ارسال نمایید.

 مقادیر **client_id** و **redirect_uri** باید منطبق بر کلید اتصال تعریف شده   توسط شما باشند.

```curl
       [sso-address]/oauth2/authorize/
    
           ?client_id=[CLIENT_ID]
    
            &response_type=[code]
    
            &redirect_uri=[REDIRECT_URI]
    
            &scope=profile
```
در صورت ورود موفق کاربر، پاسخ این درخواست در آدرس بازگشت به شکل زیر است:
دقت کنید که اگر به اسکوپ های درخواستی شما به هر دلیل اجازه دسترسی وجود نداشته باشد **Code**  خالی برگردانده می شود.

    ?code=[authorization_code]

این کد در مدت کوتاهی منقضی می شود. بنابرین بلافاصله باید نسبت به دریافت access_token و  refresh_token اقدام شود.

فهرست کامل پارامترهای این درخواست به شرح زیر است:

"**client_id**":  شناسه مشتری (اجباری)- دریافت این مقدار از پنل کسب و کار

"**response_type**":   نوع اطلاعات درخواستی - برای احراز هویت در اپلیکیشن های وب، از “code” استفاده نمایید و برای اپلیکیشن های موبایل از “token” یا “id_token” استفاده نمایید. 

"**redirect_uri**":  آدرس بازگشت- آدرس بازگشت ثبت شده برای وبسایت، مطابق با تنظیمات پنل کسب و کار

"**prompt**":  عملیات مورد نیاز-  می تواند login یا signup باشد. اگر ارسال نشود، روند عادی login طی می شود.

"**state**":  مقدار دلخواه که برنامه می خواهد در آدرس بازگشت، داشته باشد. 

"**scope**": شامل درخواست برنامه برای دسترسی به اطلاعات کاربر است- می تواند شامل یک یا چند مورد از موارد زیر باشد: profile ، email ، address ، activity ، legal، phone  مقدار پیش فرض profile:read می باشد و در صورت موافقت کاربر، توکنی که برای این scope صادر می شود فقط برای همان عملیات می تواند استفاده شود. Scope های بالا تنها اجازه خواندن اطلاعات کاربران را به شما می دهد. در صورت نیاز برای ویرایش اطلاعات کاربر :write را به انتهای اسکوپ اضافه نمایید. مثال: email:write  

"**code_challenge**": این پارامتر و پارامتر بعدی برای برنامه های بدون سرور استفاده می شوند.

"**code_challenge_method**":  متد رمز نگاری کد

**توجــــه** تخصیص اسکوپ ها توسط تیم فنی انجام خواهد شد و اسکوپ های بیشتر باید توسط کسب و کار درخواست داده شود.

## ‌دریافت توکن دسترسی کاربر
در صورتی که میخواهید کاربران شما از خدمات دیگر پلتفرم پایه مانند کیف پول استفاده نمایند، باید توکن دسترسی آنها را دریافت نمایید و با استفاده از آن، کاربر را در پلتفرم پایه ثبت نمایید. برای دریافت توکن دسترسی از درخواست زیر استفاده نمایید و علاوه بر client_secret و client_id و آدرس بازگشت، کد کاربر را نیز در آن قرار دهید.

```java
    SsoService ssoService = new SsoService();
    
            ClientInfoVo clientInfoVo = new ClientInfoVo();
    
            clientInfoVo.setClient_id(CLIENT_ID);
    
            clientInfoVo.setClient_secret(CLIENT_SECRET);
    
            try {
    
                AccessTokenVo accessTokenVo = new AccessTokenVo
    
                        .Builder()
    
                        .setClientInfoVo(clientInfoVo)
    
                        .setGrant_type(GRANT_TYPE)
    
                        .setRedirect_uri(REDIRECT_URI)
    
                        .setCode("c5c8c7a4507b48e2b164d311e08494d0")
    
    //                .setCode_verifier("")
    
                        .build();
    
                ssoService.getAccessToken(accessTokenVo, new OnGetResponseListenerGetAccessToken() {
    
                    @Override
    
                    public void onResponse(GetAccessTokenSrv getAccessTokenSrv) {
    
                        System.out.println("Access token: " + getAccessTokenSrv.getAccess_token() + "\n" +
    
                                "Refresh token: " + getAccessTokenSrv.getRefresh_token());
    
                    }
    
                    @Override
    
                    public void onFailed(PodException e) {
    
                        System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                    }
    
                });
    
            } catch (PodException e) {
    
                System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
            }
```

در این درخواست لازم است آدرس برگشت مطابق با   client_id و  client_secret و درست برابر با مقدار ارسال شده به صفحه ورود کاربران باشد. در غیر این صورت، خطای دسترسی اعلام خواهد شد.

پس از گذشت زمان expires_in ، توکن دسترسی کاربر منقضی می شود. با استفاده از refresh_token و درخواست زیر، توکن معتبر جدید درخواست دهید:

```java
       SsoService ssoService = new SsoService();
    
                ClientInfoVo clientInfoVo = new ClientInfoVo();
    
                clientInfoVo.setClient_id(CLIENT_ID);
    
                clientInfoVo.setClient_secret(CLIENT_SECRET);
    
                try {
    
                    RefreshAccessTokenVo refreshAccessTokenVo = new RefreshAccessTokenVo
    
                            .Builder()
    
                            .setClientInfoVo(clientInfoVo)
    
                            .setGrant_type("refresh_token")
    
                            .setRefresh_token("e5ded84ac41e479996c19932052f9605")
    
                            .build();
    
                    ssoService.refreshAccessToken(refreshAccessTokenVo, new OnGetResponseListenerRefreshAccessToken() {
    
                        @Override
    
                        public void onResponse(RefreshAccessTokenSrv refreshAccessTokenSrv) {
    
                            System.out.println("Access token: " + refreshAccessTokenSrv.getAccess_token() + "\n" +
    
                                    "Refresh token: " + refreshAccessTokenSrv.getRefresh_token());
    
                        }
    
                        @Override
    
                        public void onFailed(PodException e) {
    
                            System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                        }
    
                    });
    
                } catch (PodException e) {
    
                    System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                }
```

##  دریافت اطلاعات توکن‌
با استفاده از درخواست زیر می توانید از صحت و اعتبار توکن کاربر خود مطلع شوید.

```java
       SsoService ssoService = new SsoService();
    
                ClientInfoVo clientInfoVo = new ClientInfoVo();
    
                clientInfoVo.setClient_id(CLIENT_ID);
    
                clientInfoVo.setClient_secret(CLIENT_SECRET);
    
                try {
    
                    TokenInfoVo tokenInfoVo = new TokenInfoVo
    
                            .Builder()
    
                            .setClientInfoVo(clientInfoVo)
    
                            .setToken_type_hint("refresh_token")
    
                            .setToken("e5ded84ac41e479996c19932052f9605")
    
                            .build();
    
                    ssoService.getTokenInfo(tokenInfoVo, new OnGetResponseListenerGetTokenInfo() {
    
                        @Override
    
                        public void onResponse(TokenInfoSrv tokenInfoSrv) {
    
                            System.out.println("Active state: " + tokenInfoSrv.isActive());
    
                        }
    
                        @Override
    
                        public void onFailed(PodException e) {
    
                            System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                        }
    
                    });
    
                } catch (PodException e) {
    
                    System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                }
```

به عنوان **token_type_hint** سه مقدار مختلف قابل ارسال است که نوع توکن مورد نظر را مشخص می کند:

  **"access_token ,  refresh_token  , id_token"**
  
##  ابطال توکن
ممکن است به هر دلیلی بخواهید دسترسی برنامه به اطلاعات حساب کاربر را از بین ببرید. برای این منظور از درخواست زیر استفاده نمایید:

```java
    SsoService ssoService = new SsoService();
    
            ClientInfoVo clientInfoVo = new ClientInfoVo();
    
            clientInfoVo.setClient_id(CLIENT_ID);
    
            clientInfoVo.setClient_secret(CLIENT_SECRET);
    
            try {
    
                RevokeTokenVo revokeTokenVo = new RevokeTokenVo
    
                        .Builder()
    
                        .setClientInfoVo(clientInfoVo)
    
                        .setToken_type_hint("refresh_token")
    
                        .setToken("e5ded84ac41e479996c19932052f9605")
    
                        .build();
    
                ssoService.revokeToken(revokeTokenVo, new OnGetResponseListenerRevokeToken() {
    
                    @Override
    
                    public void onResponse(Void result) {
    
                        System.out.println("code : 200" + "\nmessage : " + "The operation was successful");
    
                    }
    
                    @Override
    
                    public void onFailed(PodException e) {
    
                        System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
                    }
    
                });
    
            } catch (PodException e) {
    
                System.out.println("code : " + e.getCode() + "\nmessage : " + e.getMessage());
    
            }
```

# [NodeJS](#tab/nodejs)

## SSO
برای کار با تمامی سرویس هایی پاد باید توکن دسترسی معتبر داشته باشید. همچنین کسب و کارها جهت تعریف کاربران جدید، دریافت و به روزرسانی پروفایل کاربران خود نیز می توانند از سرویس های پاد استفاده کنند که آن نیز مستلزم داشتن توکن معتبر است. تمامی کارهای دریافت و مدیریت توکن توسط ماژول SSO انجام می شود. این سامانه بر اساس استاندارد OAuth2.0 پیاده سازی شده است و دانستن این استاندارد می تواند کمک بسیاری به شما بکند.

از ماژول SSO می توانید برای ورود به دو روش وب و OTP (رمز یکبار مصرف استفاده کنید). همانطور که از نام آن مشخص است روش وب را در وب سایت ها استفاده می کنیم و از OTP اکثرا برای ورود با تلفن همراه استفاده می شود. نمونه کد های هر کدام از این دو مورد را می توانید در قسمت sample ماژول ببینید.

در روش وب، لینک ورود را مطابق با لینک زیر در وب سایت خود قرار دهید. توجه داشته باشید که client_id را می توانید در پنل کسب و کار خود پیدا کنید و آدرس بازگشت (redirect_uri) را نیز باید در این پل ثبت کنید و دقیقا همان آدرس را در این قسمت وارد کنید.

       https://accounts.pod.land/oauth2/authorize/
 
 ```curl
           ?client_id=[CLIENT_ID]
    
            &response_type=[code]
    
            &redirect_uri=[REDIRECT_URI]
    
            &scope=profile
```

**دریافت ماژول**

    npm install pod-sso-service

**ایجاد یک نمونه از ماژول:**

       const PodSSOService = require('pod-sso-service');
    
        let podSSOService = new PodSSOService({});;

**توابع:**

مربوط به وب:

1.  "getAccessToken

2. " refreshAccessToken

3.  "getTokenInfo

4.  "revokeToken

مربوط به OTP:

1. " handshake

2.  "Authorize

3.  "getOtpScenario

4.  "verify

5. " getAccessTokenByOtp

6.  "getAccessTokenByOtpScenario


##  getAccessToken
 از این تابع برای گرفتن توکن دسترسی کاربر استفاده می شود. اعتبار این توکن محدود است (15 دقیقه) و باید در صورت نیاز با تابع refreshAccessToken به روز شود. پارامتر ورودی code به آدرس برگشت شما بعد از ورود کاربر از طریق لینک ورود پاد ارسال خواهد شد.

 
```node.js
       let getAccessTokenData = {
    
          // ------ REQUIRED ------
    
          code: 'CODE',
    
          client_id: 'CLIENT ID',
    
          client_secret: 'CLIENT SECRET',
    
          redirect_uri: 'REDIRECT URI'
    
          // ------ OPTIONAL ------
    
          // grant_type: 'GRANT TYPE',
    
          // callback_uri: 'CALLBACK URI'
    
          // username: 'USERNAME'
    
          // identity: 'IDENTITY'
    
          // identityType: 'IDENTITY TYPE'
    
          // password: 'PASSWORD'
    
          // code_verifier: 'CODE VERIFIER'
    
        };
    
        podSSOService.getAccessToken(getAccessTokenData)
    
          .then(function (result) {
    
            console.log('function: getAccessToken ============>', result, '\n');
    
          })
    
          .catch(function (e) {
    
            console.log('error ============>', e);
    
          });
```

##  refreshAccessToken

 به روز رسانی توکن دسترسی کاربر

 
```node.js
    let refreshAccessTokenData = {
    
          // ------ REQUIRED ------
    
          refresh_token: 'REFRESH TOKEN',
    
          client_id: 'CLIENT ID',
    
          client_secret: 'CLIENT SECRET'
    
          // ------ OPTIONAL ------
    
          // grant_type: 'GRANT TYPE',
    
        };
    
        podSSOService.refreshAccessToken(refreshAccessTokenData)
    
          .then(function (result) {
    
            console.log('function: refreshAccessToken ============>', result, '\n');
    
          })
    
          .catch(function (e) {
    
            console.log('error ============>', e);
    
          });
```

##  getTokenInfo

  گرفتن اطلاعات توکن
 
```node.js
     let getTokenInfoData = {
    
          // ------ REQUIRED ------
    
          token: 'TOKEN',
    
          client_id: 'CLIENT ID',
    
          client_secret: 'CLIENT SECRET',
    
          token_type_hint: 'access_token | refresh_token | id_token'
    
          // ------ OPTIONAL ------
    
        };
    
        podSSOService.getTokenInfo(getTokenInfoData)
    
          .then(function (result) {
    
            console.log('function: getTokenInfo ============>', result, '\n');
    
          })
    
          .catch(function (e) {
    
            console.log('error ============>', e);
    
          });
```

## revokeToken

 ابطال توکن
 
```node.js
    let revokeTokenData = {
    
          // ------ REQUIRED ------
    
          token: 'TOKEN',
    
          client_id: 'CLIENT ID',
    
          client_secret: 'CLIENT SECRET',
    
          token_type_hint: 'access_token | refresh_token | id_token'
    
          // ------ OPTIONAL ------
    
        };
    
        podSSOService.revokeToken(revokeTokenData)
    
          .then(function (result) {
    
            console.log('function: revokeToken ============>', result, '\n');
    
          })
    
          .catch(function (e) {
    
            console.log('error ============>', e);
    
          });
```

## OTP

## handshake

 جهت ایجاد امکان ورود با رمز یکبار مصرف (OTP) برای کاربران از این تابع استفاده می شود. برای آگاهی از جزییات روند رود با رمز یکبار مصرف به لینک زیر مراجعه کنید. همچنین دقت داشته باشید که برای استفاده از روش رمز یمبار مصرف باید کلید های عمومی و خصوصی خود را ایجاد کرده باشید و کلید عمومی را در پنل کسب و کار وارد کرده باشید:

راهنما

```node.js
       let handshakeData = {
    
          // ------ REQUIRED ------
    
          device_uid: 'DEVICE UNIQUE ID',
    
          token: 'API TOKEN',
    
          client_id: 'CLIENT ID'
    
          // ------ OPTIONAL ------
    
          // device_lat: ''DEVICE LAT',
    
          // device_lon: ''DEVICE LON',
    
          // device_os: 'DEVICE OS',
    
          // device_os_version: 'DEVICE OS VERSION'
    
          // device_type: 'DEVICE TYPE',
    
          // device_name: 'DEVICE NAME',
    
          // algorithm: 'ALGORITHM'
    
        };
    
        podSSOService.handshake(handshakeData)
    
          .then(function (result) {
    
            console.log('function: handshake ============>', result, '\n');
    
          })
    
          .catch(function (e) {
    
            console.log('error ============>', e);
    
          });
```

## authorize

  بعد از عملیات handshake می توانید با استفاده از این تابع به شماره موبایل یا ایمیل کاربر رمز یکبار مصرف را ارسال کنید. مقدار کلید authorization را باید با توجه به مستندات لینک زیر ایجاد کنید:

راهنما

```node.js
       let authorizeData = {
    
          // ------ REQUIRED ------
    
          authorization: 'AUTHORIZATION HEADER',
    
          identity: 'MOBILE or EMAIL'
    
          // ------ OPTIONAL ------
    
          // response_type: 'RESPONSE TYPE'
    
          // identityType: 'IDENTITY TYPE',
    
          // loginAsUserId: 'LOGIN AS USER ID',
    
          // state: 'STATE',
    
          // redirect_uri: 'REDIRECT URI',
    
          // callback_uri: 'CALLBACK URI',
    
          // scope: 'SCOPE',
    
          // code_challenge: 'CODE CHALLENGE',
    
          // code_challenge_method: 'CODE CHALLENGE METHOD'
    
          // referrer: 'REFERRER',
    
          // referrerType: 'REFERRER TYPE'
    
        };
    
        podSSOService.authorize(authorizeData)
    
          .then(function (result) {
    
            console.log('function: handshake ============>', result, '\n');
    
          })
    
          .catch(function (e) {
    
            console.log('error ============>', e);
    
          });
```

##  getOtpScenario

  این تابع کار هر دو تابع handshake و authorize را همزمان انجام داده و شما درگیر ایجاد sign نخواهید شد

 
```node.js
       let getOtpScenarioData = {
    
          // ------ REQUIRED ------
    
          device_uid: 'DEVICE UNIQUE ID',
    
          identity: 'MOBILE or EMAIL',
    
          privateKey: 'PRIVATE KEY',
    
          token: 'API TOKEN',
    
          client_id: 'CLIENT ID'
    
          // ------ OPTIONAL ------
    
          // device_lon: 'DEVICE LON',
    
          // device_lat: 'DEVICE LAT',
    
          // device_os: 'DEVICE OS',
    
          // device_os_version: 'DEVICE OS VERSION'
    
          // device_type: 'DEVICE TYPE',
    
          // device_name: 'DEVICE NAME',
    
          // algorithm: 'ALGORITHM',
    
          // identityType: 'IDENTITY TYPE',
    
          // loginAsUserId: 'LOGIN AS USER ID',
    
          // state: 'STATE',
    
          // redirect_uri: 'REDIRECT URI',
    
          // callback_uri: 'CALLBACK URI',
    
          // scope: 'SCOPE',
    
          // code_challenge: 'CODE CHALLENGE',
    
          // code_challenge_method: 'CODE CHALLENGE METHOD'
    
          // referrer: 'REFERRE',
    
          // referrerType: 'REFERRER TYPE'
    
        };
    
        podSSOService.getOtpScenario(getOtpScenarioData)
    
          .then(function (result) {
    
            console.log('function: getOtpScenario ============>', result, '\n');
    
          })
    
          .catch(function (e) {
    
            console.log('error ============>', e);
    
          });
```

## verify

  این تابع کد پیامک شده یا ایمیل شده به کاربر را (پارامتر otp) به سرور ارسال می کنید و در صورت صحت اطلاعات ارسالی کد مورد نیاز برای ورود را دریافت خواهید کرد. مقدار کلید authorization را می توانید خود تولید کنید اما اگر در مرحله قبلی از تابع getOtpScenario سناریو استفاده کرده باشید این مقدار در خروجی تابع در اختیار شما قرار می گیرد.

  
```node.js
     let verifyData = {
    
              // ------ REQUIRED ------
    
              identity: 'MOBILE or Email',
    
              otp: 'CODE RECIEVED',
    
              authorization: 'Signature keyId=KEY ID,signature= SIGNATURE,headers=host'
    
              // ------ OPTIONAL ------
    
            };
    
            podSSOService.verify(verifyData)
    
              .then(function (result) {
    
                console.log('function: verify ============>', result, '\n');
    
              })
    
              .catch(function (e) {
    
                console.log('error ============>', e.code, e.message);
    
              });
```

## getAccessTokenByOtp

  برای دریافت توکن دسترسی در حالت ورود با رمز یکبار مصرف از این تابع استفاده می شود.  پارامتر ورودی کد از خروجی تابع verify دریافت می شود.

```node.js
      let getAccessTokenByOtpData = {
    
          // ------ REQUIRED ------
    
          code: 'CODE',
    
          client_id: 'CLIENT ID',
    
          client_secret: 'CLIENT SECRET'
    
          // ------ OPTIONAL ------
    
          // grant_type: 'GRANT TYPE',
    
        };
    
        podSSOService.getAccessTokenByOtp(getAccessTokenByOtpData)
    
          .then(function (result) {
    
            console.log('function: getAccessTokenByOtp ============>', result, '\n');
    
          })
    
          .catch(function (e) {
    
            console.log('error ============>', e.code, e.message);
    
          });
```

## getAccessTokenByOtpScenario

 این تابع کار هر دو تابع verify و getAccessTokenByOtp همزمان انجام می دهد و توکن دسترسی را بر می گرداند.

 
```node.js
       let getAccessTokenByOtpScenarioData = {
    
          // ------ REQUIRED ------
    
          identity: 'MOBILE or Email',
    
          otp: 'OTP',
    
          authorization: 'Signature keyId=KEY ID,signature= SIGNATURE,headers=host',
    
          client_id: 'CLIENT ID',
    
          client_secret: 'CLIENT SECRET'
    
          // ------ OPTIONAL ------
    
          // grant_type: 'GRANT TYPE'
    
        };
    
        podSSOService.getAccessTokenByOtpScenario(getAccessTokenByOtpScenarioData)
    
          .then(function (result) {
    
            console.log('function: getAccessTokenByOtpScenario ============>', result, '\n');
    
          })
    
          .catch(function (e) {
    
            console.log('error ============>', e.code, e.message);
    
          });
```

# [Android](#tab/android)
## OTP

نمونه کد اندروید ورود با OTP یا رمز یکبار مصرف، برای پیاده‌سازی و اجرا، نیازمند پیاده‌سازی سرور کسب و کار می‌باشد. ورود از طریق شماره موبایل و یا آدرس پست الکترونیک کاربر امکان پذیر می‌باشد و و نحوه ارسال و دریافت آن، وابسته به پیاده سازی سرور کسب و کار شماست.

در این نمونه کد، با فرض پیاده سازی سرور کسب و کار در عمومی‌ترین حالت ممکن و با ارسال **شماره موبایل و یا آدرس پست الکترونیک کاربر** به متد پیاده سازی شده در سرور (که در این نمونه کد به نام identity و با آدرس /otp/identity    یاد می‌شود)، درخواستِ ارسالِ کدِ تایید برای کاربر ثبت می‌شود، و پس از دریافت جواب در سمت کلاینت می‌بایست کاربر به صفحه وارد کردن کد تایید ارسال شده برای وی، هدایت شود. در این مرحله می‌توان از طریق متد دوم (که در این نمونه کد با نام verify و با آدرس /otp/verify یاد می‌شود)، کد وارد شده از طرف کاربر را برای سرور کسب و کار ارسال نمود و در جواب شی credential را که حاویِ access token کاربر، refresh token و ... می‌باشد را دریافت نمود.

در این نمونه کد برای ارسال درخواست‌ها از کتابخانه retrofit2 و برای ارتباط بین لایه‌های برنامه از LiveData استفاده شده است.

در این نمونه کد از یک Activity با نام LoginActivity به منظور ورود کاربر (که حاوی دو Fragment می‌باشد) و یک Acitivity  با نام MainActivity به عنوان صفحه اصلی استفاده شده است.  IdentityFragment شامل دریافت identity از کاربر و درخواست برای ارسال آن می‌باشد. و VerifyFragment نیز مسئولیت دریافت کد verify از کاربر و دریافت credential می‌باشد. (می‌توانید token  و دیگر موارد را در این قسمت دریافت و نگهداری نمایید.)

دسترسی به نمونه کد اندروید

https://github.com/FanapSoft/pod-otp-android-sample-code

<div class="tab-end">
</div>
